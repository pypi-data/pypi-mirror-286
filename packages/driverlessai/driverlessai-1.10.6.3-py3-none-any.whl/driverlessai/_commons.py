import abc
import collections.abc
import os
import time
from typing import Any
from typing import Callable
from typing import List
from typing import Optional
from typing import Sequence
from typing import TYPE_CHECKING
from typing import Union

import tabulate

from driverlessai import _core
from driverlessai import _enums
from driverlessai import _utils

if TYPE_CHECKING:
    import fsspec  # noqa F401


class ServerObject(abc.ABC):
    """Interact with an entity on the Driverless AI server."""

    def __init__(self, client: "_core.Client", key: Optional[str] = None) -> None:
        self._client = client
        self._key = key
        self._name: Optional[str] = None
        self._raw_info: Any = None

    @property
    def key(self) -> str:
        """Universally unique identifier."""
        if not self._key:
            raise RuntimeError(
                "The Driverless AI server does not provide a universally "
                "unique identifier for this object type."
            )
        return self._key

    @property
    def name(self) -> str:
        """Display name."""
        if not self._name:
            self._update()
        return self._name

    def _get_raw_info(self) -> Any:
        """Returns an undefined object that contains all entity information
        generated by the Driverless AI server. The returned object usually has
        the method ``dump()`` to convert it to a dictionary.
        """
        if not self._raw_info:
            self._update()
        return self._raw_info

    def _set_name(self, name: str) -> None:
        """Use when name is cached before initialization."""
        self._name = name

    def _set_raw_info(self, info: Any) -> None:
        """To be used by ``_update()`` method."""
        self._raw_info = info

    @abc.abstractmethod
    def _update(self) -> None:
        """Updates the object's raw info, name, and properties."""
        raise NotImplementedError


class ServerJob(ServerObject):
    """Monitor a job on the Driverless AI server."""

    def __init__(self, client: "_core.Client", key: str) -> None:
        super().__init__(client=client, key=key)

    def is_complete(self) -> bool:
        """Return ``True`` if job completed successfully."""
        return is_server_job_complete(self._status())

    def is_running(self) -> bool:
        """Return ``True`` if job is scheduled, running, or finishing."""
        return is_server_job_running(self._status())

    def _status(self) -> _enums.JobStatus:
        self._update()
        return _enums.JobStatus(self._get_raw_info().status)

    def _wait(self, silent: bool = False) -> None:
        status_update = _utils.StatusUpdate()
        while self.is_running():
            time.sleep(1)
            if not silent:
                status_update.display(self.status(verbose=2))
        if not silent:
            status_update.display(self.status(verbose=2))
        status_update.end()
        if not self.is_complete():
            raise RuntimeError(
                self._client._backend._format_server_error(self._get_raw_info().error)
            )

    @abc.abstractmethod
    def result(self, silent: bool = False) -> Any:
        """Wait for job to complete.

        Args:
            silent: if True, don't display status updates
        """
        raise NotImplementedError

    def status(self, verbose: int = 0) -> str:
        """Return job status string.

        Args:
            verbose:
                - 0: short description
                - 1: short description with progress percentage
                - 2: detailed description with progress percentage
        """
        status = self._status()
        progress = self._get_raw_info().progress
        # server doesn't always show 100% complete
        if self.is_complete():
            progress = 1
        if verbose == 1:
            return f"{status.message} {progress:.2%}"
        if verbose == 2:
            if status == _enums.JobStatus.FAILED:
                message = self._get_raw_info().error
            elif self._get_raw_info().message:
                message = self._get_raw_info().message.split("\n")[0]
            else:
                message = ""
            return f"{status.message} {progress:.2%} - {message}"
        return status.message


class ArtifactExportJob(ServerJob):
    """Monitor export job on the Driverless AI server."""

    def __init__(
        self,
        client: "_core.Client",
        key: str,
        artifact_path: str,
        artifact_file_name: str,
        export_location: str,
    ) -> None:
        # super() calls _update() which relies on artifact_path
        self._artifact_path = artifact_path
        super().__init__(client=client, key=key)
        self._artifact_file_name = artifact_file_name
        self._export_location = export_location

    @property
    def artifact_path(self) -> str:
        """Path to artifact on Driverless AI server."""
        return self._artifact_path

    @property
    def artifact_file_name(self) -> str:
        """Name of artifact file."""
        return self._artifact_file_name

    @property
    def export_location(self) -> str:
        """Location being exported to."""
        return self._export_location

    def _update(self) -> None:
        self._set_raw_info(
            self._client._backend.get_artifact_upload_job(
                key=self.key, artifact_path=self.artifact_path
            )
        )

    def result(self, silent: bool = False) -> None:
        self._wait(silent)

    def status(self, verbose: int = None) -> str:
        status = self._status()
        if status == _enums.JobStatus.FAILED:
            message = f" - {self._get_raw_info().error}"
        else:
            message = f" - Export {self.artifact_file_name} to {self.export_location}"
        return f"{status.message}{message}"


class ServerJobs:
    """Monitor multiple jobs on the Driverless AI server."""

    def __init__(self, client: "_core.Client", jobs: Sequence[ServerJob]) -> None:
        self._client = client
        self._jobs = jobs

    @property
    def jobs(self) -> Sequence[ServerJob]:
        """List of ServerJob objects."""
        return self._jobs

    def is_complete(self) -> bool:
        """Return ``True`` if all jobs completed successfully."""
        for job in self.jobs:
            if not job.is_complete():
                return False
        return True

    def is_running(self) -> bool:
        """Return ``True`` if one or more jobs is running or finishing."""
        for job in self.jobs:
            if job.is_running():
                return True
        return False

    def result(self, silent: bool = False) -> Any:
        """Wait for all jobs to complete.

        Args:
            silent: if True, don't display status updates
        """
        return [job.result(silent) for job in self.jobs]

    def status(self, verbose: int = 0) -> List[str]:
        """Returns list of job status strings.

        Args:
            verbose:
                - 0: short description
                - 1: short description with progress percentage
                - 2: detailed description with progress percentage
        """
        return [job.status(verbose) for job in self.jobs]


class StorageImportJob(ServerJob):
    def __init__(self, client: "_core.Client", key: str) -> None:
        super().__init__(client=client, key=key)

    def _update(self) -> None:
        self._set_raw_info(self._client._backend.get_import_entity_job(self.key).status)

    def result(self, silent: bool = True) -> "StorageImportJob":
        self._wait(silent=silent)
        return self


class ServerLog:
    def __init__(self, client: "_core.Client", file_path: str) -> None:
        self._client = client
        self._file_name = os.path.basename(file_path)
        self._file_path = file_path

    # Do we need to deprecate and add again ?
    @property
    def file_name(self) -> str:
        """Filename of the log file."""
        return self._file_name

    def _download(
        self,
        server_path: str = "",
        dst_dir: str = ".",
        dst_file: Optional[str] = None,
        file_system: Optional["fsspec.spec.AbstractFileSystem"] = None,
        overwrite: bool = False,
        timeout: float = 30,
        download_type: _enums.DownloadType = _enums.DownloadType.FILES,
    ) -> str:
        """Download logs from the Driverless AI server.

        Args:
            server_path: if you want to get the file other than the file_path
                use this.
            dst_dir: directory where logs will be saved
            dst_file: name of log file (overrides default file name)
            file_system: FSSPEC based file system to download to,
                instead of local file system
            overwrite: overwrite existing file
            timeout: connection timeout in seconds
            download_type: download type, whether to choose from a file, dataset, or log
        """
        if len(server_path) == 0:
            server_path = self._file_path
        return self._client._download(
            server_path=server_path,
            dst_dir=dst_dir,
            dst_file=dst_file,
            file_system=file_system,
            overwrite=overwrite,
            timeout=timeout,
            download_type=download_type,
        )

    def head(self, num_lines: int = 50) -> str:
        """Print first n lines of log.

        Args:
            num_lines: number of lines to print
        """
        res = self._client._get_response(server_path=self._file_path, stream=True)
        lines = []
        for i, line in enumerate(res.iter_lines(decode_unicode=True)):
            if i >= num_lines:
                break
            lines.append(line.decode("utf-8"))
        return "\n".join(lines)

    def tail(self, num_lines: int = 50) -> str:
        """Print last n lines of log.

        Args:
            num_lines: number of lines to print
        """
        res = self._client._get_response(server_path=self._file_path, stream=True)
        lines = []
        for line in res.iter_lines(decode_unicode=True):
            lines.append(line.decode("utf-8"))
            if len(lines) > num_lines:
                lines.pop(0)
        return "\n".join(lines)


class ServerObjectList(collections.abc.Sequence):
    """List that lazy loads Driverless AI server objects."""

    def __init__(self, data: Any, get_method: Optional[Callable], item_class_name: str):
        self._data = data
        self._get = get_method
        self._item_class_name = item_class_name

    def __getitem__(self, index: Union[int, slice, tuple]) -> Any:
        if isinstance(index, int):
            if not hasattr(self._data[index], "_client") and self._get is not None:
                item = self._get(self._data[index].key)
                item._set_name(
                    getattr(self._data[index], "name", "")
                    or getattr(self._data[index], "description", "")
                )
                self._data.__setitem__(index, item)
            return self._data[index]
        if isinstance(index, slice):
            return ServerObjectList(self._data[index], self._get, self._item_class_name)
        if isinstance(index, tuple):
            return ServerObjectList(
                [self._data[i] for i in index], self._get, self._item_class_name
            )

    def __len__(self) -> int:
        return len(self._data)

    def __repr__(self) -> str:
        headers = ["", "Type", "Key", "Name"]
        if self._get is None:
            table = [
                [
                    i,
                    self._item_class_name,
                    None,
                    f"{getattr(d, 'name', '') or getattr(d, 'description', '')}",
                ]
                for i, d in enumerate(self._data)
            ]
        else:
            table = [
                [
                    i,
                    self._item_class_name,
                    d.key,
                    f"{getattr(d, 'name', '') or getattr(d, 'description', '')}",
                ]
                for i, d in enumerate(self._data)
            ]
        return tabulate.tabulate(table, headers=headers, tablefmt="presto")


def is_server_job_complete(server_job_status: Union[int, _enums.JobStatus]) -> bool:
    return server_job_status == _enums.JobStatus.COMPLETE


def is_server_job_failed(server_job_status: Union[int, _enums.JobStatus]) -> bool:
    return server_job_status == _enums.JobStatus.FAILED


def is_server_job_running(server_job_status: Union[int, _enums.JobStatus]) -> bool:
    return server_job_status in [
        _enums.JobStatus.FINISHING,
        _enums.JobStatus.RUNNING,
        _enums.JobStatus.SCHEDULED,
        _enums.JobStatus.SYNCING,
    ]
