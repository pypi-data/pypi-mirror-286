# generated by datamodel-codegen:
#   filename:  grammar-schema.json
#   timestamp: 2024-07-20T19:49:12+00:00

from __future__ import annotations

from typing import Any, Union, Literal

from pydantic import BaseModel, ConfigDict, Field, constr


class BlankRule(BaseModel):
    type: Literal["BLANK"]


class StringRule(BaseModel):
    type: Literal["STRING"]
    value: str


class PatternRule(BaseModel):
    type: Literal["PATTERN"]
    value: str
    flags: str | None = None


class SymbolRule(BaseModel):
    type: Literal["SYMBOL"]
    name: str


class TreeSitterGrammarSpecification(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: constr(pattern=r"^[a-zA-Z_]\w*") = Field(
        ...,
        description="the name of the grammar",
    )
    inherits: constr(pattern=r"^[a-zA-Z_]\w*") | None = Field(
        None,
        description="the name of the parent grammar",
    )
    rules: dict[constr(pattern=r"^[a-zA-Z_]\w*$"), Rule]
    extras: list[Rule] | None = None
    precedences: list[list[Rule]] | None = None
    externals: list[Rule] | None = None
    inline: list[constr(pattern=r"^[a-zA-Z_]\w*$")] | None = None
    conflicts: list[list[constr(pattern=r"^[a-zA-Z_]\w*$")]] | None = None
    word: constr(pattern=r"^[a-zA-Z_]\w*") | None = None
    supertypes: list[str] | None = Field(
        None,
        description="A list of hidden rule names that should be considered supertypes in the generated node types file. See https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types.",
    )


class SeqRule(BaseModel):
    type: Literal["SEQ"]
    members: list[Rule]


class ChoiceRule(BaseModel):
    type: Literal["CHOICE"]
    members: list[Rule]


class AliasRule(BaseModel):
    type: Literal["ALIAS"]
    value: str
    named: bool
    content: Rule


class RepeatRule(BaseModel):
    type: Literal["REPEAT"]
    content: Rule


class Repeat1Rule(BaseModel):
    type: Literal["REPEAT1"]
    content: Rule


class TokenRule(BaseModel):
    type: Literal["TOKEN", "IMMEDIATE_TOKEN"]
    content: Rule


class FieldRule(BaseModel):
    name: str
    type: Literal["FIELD"]
    content: Rule


class PrecRule(BaseModel):
    type: Literal["PREC", "PREC_LEFT", "PREC_RIGHT", "PREC_DYNAMIC"]
    value: Any
    content: Rule


Rule = Union[
    AliasRule,
    BlankRule,
    StringRule,
    PatternRule,
    SymbolRule,
    SeqRule,
    ChoiceRule,
    Repeat1Rule,
    RepeatRule,
    TokenRule,
    FieldRule,
    PrecRule,
]


TreeSitterGrammarSpecification.model_rebuild()
SeqRule.model_rebuild()
ChoiceRule.model_rebuild()
AliasRule.model_rebuild()
RepeatRule.model_rebuild()
Repeat1Rule.model_rebuild()
TokenRule.model_rebuild()
FieldRule.model_rebuild()
PrecRule.model_rebuild()
