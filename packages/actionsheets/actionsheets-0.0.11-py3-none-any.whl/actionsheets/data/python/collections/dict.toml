language = "python"
parent = "python.collections"
name = "dict"
title = "Dict"
description = "Maps hashable objects to a value"
details = ""


[create]
section = "Create"
description = "Define a dictionary"

[create.empty]
action = "Empty"
code = "x = {}"

[create.string]
action = "Define with string keys"
code = "x = {'color': 'blue', 'size': 'large'}"

[create.int]
action = "Define with integer keys"
code = "x = {1: 'a', 2: 'b', 3: 'c'}"

[create.iter.fill]
action = "Define from keys iterator and constant value _v_"
code = "dict.fromkeys(key_iter, v)"
keywords = "fill"

[create.iter.kv]
action = "Define dynamically from iterators for keys and values"
code = "x = dict(zip(key_iter, value_iter))"

[create.merge]
action = "Merge dictionaries"
code = "z = x | y"

[create.merge.unpack]
code = "z = {**x, **y}"


[test]
section = "Test"

[test.is]
action = "Is dict"
code = "x is dict"

[test.inherits]
action = "Is dict or subclass"
code = "isinstance(x, dict)"

[test.empty]
action = "Empty"
code = "if x:"

[test.nempty]
action = "Not empty"
code = "if not x:"

[test.contains.key]
action = "Contains key _k_"
code = "k in x"

[test.contains.value]
action = "Contains value _v_"
code = "v in x.values()"

[test.contains.value.none]
action = "Contains value `None`"
code = "None in x.values()"

[test.contains.keys]
action = "Contains specific keys"
code = "{k1, k2}.issubset(x)"

[test.contains.keys.dyn]
action = "Contains keys _keys_"
code = "set(keys).issubset(x)"

[test.contains.values]
action = "Contains specific values"
code = "{v1, v2}.issubset(x.values())"

[test.contains.values.dyn]
action = "Contains values _values_"
code = "set(values).issubset(x.values())"

[test.contains.duplicate]
action = "Contains duplicate values"
code = "len(x) != len(set(x.values()))"


[get]
section = "Get"

[get.value]
action = "Value"
code = "x['color']"
details = "Throws an error if missing"

[get.value.try]
action = "Try get value"
code = "x.get('color')"
details = "Returns `None` if missing"

[get.value.try.default]
action = "Try get value with default _v_"
code = "x.get('color', v)"

[get.values.keys.list]
action = "Values from list of keys"
code = "[x[k] for k in keys_list]"

[get.keys]
action = "Keys"
code = "x.keys()"
details = "As `dict_keys`"

[get.keys.list]
action = "Keys as list"
code = "list(x)"

[get.keys.list.sorted]
action = "Keys as sorted list"
code = "sorted(x)"

[get.values]
action = "Values"
code = "x.values()"
details = "As `dict_values`"

[get.values.list]
action = "Values as list"
code = "list(x.values())"

[get.values.sorted]
action = "Values sorted by keys"
code = "[x[k] for k in sorted(x)]"

[get.entries]
action = "Entries (as list of tuples)"
code = "x.items()"

[get.key.value.first]
action = "First key with value _v_"
code = "next(k for k in x if x[k] == v)"

[get.keys.value.all]
action = "All keys with value _v_"
code = "[k for k in x if x[k] == v]"


[update]
section = "Update"

[update.default]
action = "Set default entry value for missing key"
code = "x.setdefault('size', 'medium')"

[update.entry]
action = "Update entry value"
code = "x['size'] = 'small'"

[update.entry.ifexists]
action = "Update entry, error if missing"
code = "?"
details = "?"

[update.rename]
action = "Rename entry"
code = "x['new'] = x.pop('old')"


[update.grow]
section = "Grow"

[update.grow.add]
action = "Add/update entry"
code = "x['size'] = 'small'"

[update.grow.merge]
action = "Merge with another dictionary"
code = "x |= y"

[update.grow.merge.fun]
code = "x.update(y)"


[update.shrink]
section = "Shrink"

[update.shrink.remove.entry]
action = "Remove entry by key"
code = "del x['size']"

[update.shrink.remove.entries]
action = "Remove entries by keys"
code = "for k in keys: del x[k]"

[update.shrink.pop.entry]
action = "Remove entry by key, get value"
code = "x.pop('size')"

[update.shrink.pop.entries]
action = "Remove keys, get values"
code = "[x.pop(k) for k in keys]"

[update.shrink.pop.last]
action = "Remove last entry, get value"
code = "x.popitem()"

[update.shrink.clear]
action = "Clear (remove all entries)"
code = "x.clear()"


[derive]
section = "Derive"

[derive.copy]
action = "Copy"
code = "x.copy()"

[derive.copy.new]
code = "dict(x)"

[derive.subset.keys]
action = "Subset for keys"
code = "{k: x[k] for k in keys}"
details = "Error if a key is missing"

[derive.subset.keys.default]
action = "Subset for keys with default _v_"
code = "{k: x.get(k, default=v) for k in keys}"

[derive.subset.keys.intersect]
action = "Subset (intersection) for keys"
code = "{k: x[k] for k in x.keys() if k in keys}"
details = "Returns empty dict if all keys are missing"

[derive.subset.keys.diff]
action = "Subset except for keys"
code = "{k: x[k] for k in x.keys() if k not in keys}"


[convert]
section = "Convert"

[convert.pretty]
action = "Pretty print"
code = "pprint.pprint(x)"

[convert.list]
action = "List of key-value tuples"
code = "x.items()"

[convert.json]
action = "JSON string"
code = "json.dumps(x)"

[convert.json.robust]
action = "JSON string, handle non-string entries"
code = "json.dumps(x, default = str)"
