language = "python"
parent = "python.collections"
name = "list"
title = "List"
description = "An ordered collection of elements"
details = """
Tips:
* Lists can be efficiently used as a stack through `append()` (for push) and `pop()`.
* Sorting seems to be broken for numeric lists containing NaN
"""

[create]
section = "Create list"

[create.empty]
action = "Empty"
code = "x = []"

[create.define]
action = "Define"
code = "x = [1, 3, 9]"

[create.fill]
action = "Define with _n_ repeated values _v_"
code = "x = [v] * n"

[create.tuple]
action = "From tuple"
code = """
t = (1, 3, 9)
x = [t]
"""
details = "Faster than `list(t)`"

[create.iter]
action = "From iterator (consumes)"
code = "x = list(iter)"

[create.zipped]
action = "Lists from zipped list"
code = """
a = (1, 2); b = (-1, -2)
ab = zip(a, b)
a2, b2 = zip(*ab)
"""

[create.sample]
action = "Sample _n_ random numbers between [ _a_, _b_ ) with replacement"
code = "random.choices(range(a, b), k=n)"
details = "Considerably faster than list comprehension"

[create.sample.wo]
action = "Sample _n_ random numbers between [ _a_, _b_ ) w/o replacement"
code = "random.sample(range(a, b), n)"

[create.lists.iter]
action = "From different lists, generated dynamically by iterating over a list-generating function"
code = """
list(itertools.chain.from_iterable(
    [generate_my_list(e) for e in entries]
))
"""

[test]
section = "Test"

[test.is]
action = "Is list"
code = "type(x) is list"

[test.inherits]
action = "Is list or subclass"
code = "isinstance(x, list)"

[test.empty]
action = "Empty"
code = "if x:"

[test.nempty]
action = "Not empty"
code = "if not x:"

[test.equal]
action = "Pairwise equal"
code = "x == y"

[test.contains.none]
action = "Contains `None`"
code = "None in x"

[test.contains.elem]
action = "Contains element"
code = "e in x"

[test.missing.elem]
action = "Does not contain element"
code = "e not in x"

[test.contains.elem.multi]
action = "Contains elements"
code = "{1, 2}.issubset(x)"

[test.contains.elem.multi.dyn]
action = "Contains elements _elems_"
code = "set(elems).issubset(x)"

[test.elem.type.all]
action = "Elements are all of type"
code = "all(isinstance(e, str) for e in x)"

[test.elem.true.all]
action = "All elements True"
code = "all(x)"

[test.elem.true.any]
action = "Any element True"
code = "any(x)"

[test.elem.sorted]
action = "Are elements sorted"
code = "x == sorted(x)"

[test.elem.duplicate.none]
action = "No duplicate elements"
code = "len(x) == len(set(x))"

[test.elem.duplicate.any]
action = "Has duplicate elements"
code = "len(x) != len(set(x))"


[get]
section = "Get"

[get.len]
action = "Number of elements (length)"
code = "len(x)"

[get.elem.first]
action = "First element"
code = "x[0]"

[get.elem.last]
action = "Last element"
code = "x[-1]"

[get.elem.slice]
action = "Slice"
code = "x[1:3]"

[get.elem.head]
action = "First _n_ elements (head)"
code = "x[:n]"

[get.elem.tail]
action = "Last _n_ elements"
code = "x[-n:]"

[get.elem.list.indices]
action = "List of elements from a list of indices"
code = "[x[i] for i in indices]"

[get.elem.count]
action = "Number of occurrences of element"
code = "x.count(e)"

[get.elem.index]
action = "Index of element"
code = "x.index(e)"
details = "Throws error if not found"

[get.elem.index.slice]
action = "Index of element in slice [a,b]"
code = "x.index(e, a, b)"
details = "Throws error if not found"


[aggregate]
section = "Aggregation functions"

[aggregate.min]
action = "Min"
code = "min(x)"

[aggregate.max]
action = "Max"
code = "max(x)"

[aggregate.sum]
action = "Sum"
code = "sum(x)"

[aggregate.mean]
action = "Mean"
code = "sum(x) / len(x)" 
details = "Faster than `fmean` and `mean` from `statistics`"

[aggregate.mode]
action = "Most frequent element (mode)"
code = "statistics.mode(x)"


[update]
section = "Update"

[update.elem.at]
action = "Update element at index _i_"
code = "x[i] = e2"

[update.elem.slice]
action = "Update slice with list"
code = "x[2:3] = [5, 6]"

[update.order.reverse]
action = "Reverse elements"
code = "x.reverse()"

[update.order.sort]
action = "Sort elements ascending"
code = "x.sort()"

[update.order.sort.desc]
action = "Sort elements descending"
code = "x.sort(reverse=True)"

[update.order.sort.transform]
action = "Sort on transformed elements, ascending"
code = "x.sort(key=str.lower)"

[update.order.sort.natural]
action = "Naturally sort string elements"
code = """
from natsort import natsorted
natsorted(x)
"""
details = "E.g., sort as ['abc1', 'abc2', 'abc10']. Uses the natsort package."

[update.order.shuffle]
action = "Shuffle elements"
code = "random.shuffle(x)"


[shrink]
section = "Remove elements"

[shrink.clear]
action = "Clear"
code = "x.clear()"

[shrink.clear.slice]
code = "x[:] = []"
details = "Probably slower"

[shrink.remove.index]
action = "Remove at index _i_"
code = "del x[i]"

[shrink.remove.index.empty]
code = "x[i] = []"

[shrink.pop.last]
action = "Remove last index and return the element (pop)"
code = "x.pop()"

[shrink.pop.index]
action = "Remove at index _i_ and return the element"
code = "x.pop(e, i)"

[shrink.remove.slice]
action = "Remove slice"
code = "del x[2:3]"

[shrink.remove.slice.empty]
code = "x[2:3] = []"

[shrink.remove.elem.first]
action = "Remove element (first occurrence)"
code = "x.remove(e)"

[shrink.remove.elem.all]
action = "Remove all elements with value"
code = "?"


[grow]
section = "Grow"

[grow.append.elem]
action = "Append element"
code = "x.append(e)"

[grow.append.list]
action = "Append a list"
code = "x += y"

[grow.append.list.extend]
code = "x.extend(y)"

[grow.insert.index]
action = "Insert at index _i_"
code = "x.insert(i, e)"


[derive]
section = "Derive"


[derive.map]
section = "Map elements"
description = "Derive a new one-to-one list"

[derive.map.copy.shallow]
action = "Shallow copy"
code = "x.copy()"
details = "Fastest for large lists"

[derive.map.copy.shallow.unpack]
code = "[*x]"
details = "Fastest for small lists"

[derive.map.copy.shallow.slice]
code = "x[:]"
details = "Probably very slow"

[derive.map.copy.shallow.copy]
code = "copy.copy(x)"
details = "Not sure what the difference to `.copy()` is"

[derive.map.copy.deep]
action = "Deep copy (don't preserve refs)"
code = "copy.deepcopy(x)"
details = "Constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original."

[derive.map.reserve]
action = "Reversed order"
code = "reversed(x)"

[derive.map.rank]
action = "Rank ascendingly"
code = "list(scipy.stats.rankdata(x))"
details = "Uses scipy package"

[derive.map.sorti]
action = "Sort-index ascendingly"
code = "list(np.argsort(x))"
details = "Uses numpy package"

[derive.map.sorti.sorted]
code = "sorted(range(len(x)), key=x.__getitem__)"

[derive.map.sorti.comprehension]
code = "[e[0] for e in sorted(enumerate(x), key=lambda x: x[1])]"
details = "Tedious"

[derive.map.sort]
action = "Sorted ascendingly"
code = "sorted(x)"
details = "Elements must be sortable!"

[derive.map.sort.desc]
action = "Sorted descendingly"
code = "sorted(x, reverse=True)"
details = "Elements must be sortable!"

[derive.map.sort.order]
action = "Sorted by reference order"
code = "[x for _, x in sorted(zip(ref_order, x))]"

[derive.map.comprehension]
action = "Transform via comprehension"
code = "[e + 1 for e in x]"

[derive.map.fun]
action = "Map function"
code = "[fun(e) for e in x]"

[derive.map.fun.map]
code = "list(map(fun, x))"
details = "Slow"

[derive.map.cond]
action = "Conditional update"
code = "[e if e != 0 else -1 for e in x]"

[derive.map.ternary]
action = "Ternary map"
code = "[e if e > 2 else 10 for e in x]"

[derive.map.ternary.nested]
action = "Nested ternary map"
code = "[e if e > 2 else 10 if e < 3 else 5 for e in x]"
details = "Good luck reading this"

[derive.map.filter.cond]
action = "Filter on condition"
code = "[e for e in x if e > 0]"

[derive.map.filter.predicate]
action = "Filter on predicate function"
code = "filter(fun, x)"

[derive.map.str]
action = "Elements to string"
code = "[str(e) for e in x]"


[derive.grow]
section = "Grow"
description = "Derive a larger list"

[derive.grow.rep]
action = "Replicate _n_ times"
code = "x * n"

[derive.grow.rep.len]
action = "Replicate to ensure length _n_"
code = "?"

[derive.grow.list]
action = "Append a list"
code = "x + y"


[iter]
section = "Iterate"
description = "Iterate over the elements of the list"

[iter.for]
action = "For-loop"
code = "for e in x:"

[iter.for.index]
action = "For-loop with index"
code = "for i, e in enumerate(x):"

[iter.for.index.start]
action = "Iterate with index starting from _s_"
code = "for i, e in enumerate(x, s):"

[iter.for.lists]
action = "Iterate over multiple lists"
code = "for a, b in zip(x, y):"

[iter.for.lists.index]
action = "Iterate over multiple lists with index"
code = "for i, (a, b) in enumerate(zip(x, y)):"

[iter.lists.nested]
action = "Iterate over a list of lists for each nested element"
code = "itertools.chain.from_iterable(x)"


[convert]
section = "Convert"

[convert.assign]
action = "Multiple assignment"
code = """
x = [1, 2]
a, b = x
"""

[convert.hash]
action = "Hash"
code = "hash(tuple(x))"

[convert.tuple]
action = "Tuple"
code = "tuple(x)"

[convert.set]
action = "Set"
code = "set(x)"

[convert.dict]
action = "To dict (from keys and values)"
code = "dict(zip(keys, values))"

[convert.flatten]
action = "Flatten a list of lists"
code = "list(itertools.chain.from_iterable(x))"
