"""
Provides classes and methods for the creation of grid block supports for use typically in metal Additive Manufacturing
"""
from enum import IntEnum
from typing import Any, Optional, List, Tuple, Union
import logging

import warnings

import scipy.ndimage.filters
import trimesh
from scipy import interpolate

import shapely.geometry
import shapely.affinity

import numpy as np
import trimesh.path
import trimesh.path.traversal

import pyclipr

from .support import BlockSupportBase, BlockSupportGenerator
from .utils import *
from .geometry import *
from ..hatching import BaseHatcher
from ..hatching import utils as hatchingUtils

class GridMeshType(IntEnum):
    """
    The mesh definition for each part of a grid truss support structure
    """

    BOUNDARY = 0
    """
    A truss network is used to generate the support structure
    """

    SLICE_X = 1
    """
    A slice along the x-direction
    """

    SLICE_Y = 2
    """
    A slice along the y-direction
    """

class GridBlockSupport(BlockSupportBase):
    """
    Represents a block support that internally generates a grid truss structure representing the support structure. The
    grid is generated by taking a sequence of cross-sections at a fixed distance (:attr:`~GridBlockSupport.gridSpacing`)
    from the generated support volume (:attr:`~BlockSupportBase.supportVolume`).

    The 2D slices along the grid are generated in :meth:`generateSupportSlices` and produce a 2D grid of
    cross-sections as polygons. Each polygon slice can  be designed to include  patterns such as perforation holes
    or a truss network. Potentially the 2D slices may be extruded and offset to increase the support strength,
    if required. A surrounding border with a conformal truss grid is also generated using
    :meth:`~GridBlockSupport.generateSupportSkins`.

    A truss network is generated to reduce the amount of support material processed, but additionally provides internal
    perforations which aid powder support removal after production. The truss network in 2D is generated
    along with supporting functions for creating a mesh. The generation of the truss grid is relatively expensive to
    generated compared to the polygon intersection and may be disabled by setting
    :attr:`~GridBlockSupport.generateTrussGrid`).

    Furthermore, penetrating teeth located at the upper and lower intersection of the support volume can be generated
    to ease support removal for metal AM processes. A variety of configurable options are included to vary the
    geometry. The tooth sizes may be specified using :attr:`~GridBlockSupport.supportTeethHeight`,
    :attr:`~GridBlockSupport.supportTeethTopLength`, :attr:`~GridBlockSupport.supportTeethBottomLength`,
    :attr:`~GridBlockSupport.supportTeethBaseInterval` and an additional self-penetration distance (
    :attr:`~GridBlockSupport.supportTeethUpperPenetration` and
    :attr:`~GridBlockSupport.supportTeethLowerPenetration`) to enhance the strength of the support by over- scanning
    material within the solid part internally. The tooth profile is repeated across the upper edge of the intersected
    support volume using an internal overrideable function :meth:`toothProfile`. The generation of support teeth on
    the upper and lower surfaces may be individually toggled by setting
    :attr:`~GridBlockSupport.useUpperSupportTeeth` and :attr:`~GridBlockSupport.useLowerSupportTeeth` respectively.
    If the user desires to strengthen the support near the upper and lower surfaces near the support teeth,
    and additional offsetting can be applied using :attr:`~GridBlockSupport.supportWallThickness`.

    The truss is designed to self-intersect at set distance based on both the :attr:`trussAngle` and
    the :attr:`gridSpacing` so that they combine as a consistently connected support mesh. Upon
    generating a polygon for each support slice, this is triangulated via :meth:`triangulatePolygon`
    to create a mesh which may be sliced and hatched later. Optionally these may be combined into a single mesh, for
    exporting externally.
    """

    _pairTolerance = 1e-1
    """
    Pair tolerance used for matching upper and lower paths of the support boundary. This is an internal tolerance
    used but may be re-defined by the user."""


    def __init__(self, supportObject: Part = None,
                       supportVolume: trimesh.Trimesh = None,
                       supportSurface: trimesh.Trimesh = None,
                       intersectsPart: bool = False):

        super().__init__(supportObject, supportVolume, supportSurface, intersectsPart)

        self._gridSpacing = [3, 3] # mm
        self._useSupportBorder = True
        self._useSupportSkin = True
        self._supportWallThickness = 0.5
        self._supportBorderDistance = 3.0
        self._generateTrussGrid = True
        self._trussWidth = 1.0
        self._trussAngle = 45
        self._mergeMesh = False
        self._numSkinMeshSubdivideIterations = int(2)

        self._supportTeethHeight = 1.5  # mm
        self._supportTeethTopLength = 0.1 # mm
        self._supportTeethBottomLength = 1.5 # mm
        self._supportTeethBaseInterval = 0.2 # mm
        self._supportTeethUpperPenetration = 0.2 # mm

        self._useUpperSupportTeeth = True
        self._useLowerSupportTeeth = False

    def __str__(self):
        return 'GridBlockSupport'

    @property
    def numSkinMeshSubdivideIterations(self) -> int:
        """
        Number of times to subdivide the exterior skin of the support mesh to increase the resolution to improve the
        quality of output mesh in order for this to conform with the boundary of the support block volume.
        The default value is 2.
        """
        return self._numSkinMeshSubdivideIterations

    @numSkinMeshSubdivideIterations.setter
    def numSkinMeshSubdivideIterations(self, iterations: int):
        self._numSkinMeshSubdivideIterations = int(iterations)

    @property
    def supportWallThickness(self) -> float:
        """
        An offset thickness applied to the lower and upper edges adjacent to the perforated teeth of the supports to
        provide additional strength
        """
        return self._supportWallThickness

    @supportWallThickness.setter
    def supportWallThickness(self, wallThickness: float):
        self._supportWallThickness = wallThickness

    @property
    def useUpperSupportTeeth(self) -> bool:
        """
        Determines if the penetrating support teeth should be generated on the upper surface of the support volume
        """
        return self._useUpperSupportTeeth

    @useUpperSupportTeeth.setter
    def useUpperSupportTeeth(self, state: bool):
        self._useUpperSupportTeeth = state

    @property
    def useLowerSupportTeeth(self) -> bool:
        """
        Determines if the penetrating support teeth should be generated on the lower surface of the support volume
        """
        return self._useLowerSupportTeeth

    @useLowerSupportTeeth.setter
    def useLowerSupportTeeth(self, state: bool):
        self._useLowerSupportTeeth = state
    @property
    def supportTeethHeight(self) -> float:
        """
        The height of the perforated support teeth
        """
        return self._supportTeethHeight

    @supportTeethHeight.setter
    def supportTeethHeight(self, teethHeight: float):
        self._supportTeethHeight = teethHeight

    @property
    def supportTeethTopLength(self):
        """
        The upper span or length of the perforated support teeth
        """
        return self._supportTeethTopLength

    @supportTeethTopLength.setter
    def supportTeethTopLength(self, topLength: float):
        self._supportTeethTopLength = topLength

    @property
    def supportTeethBottomLength(self) -> float:
        """
        The bottom span or length of the perforated support teeth
        """
        return self._supportTeethTopLength

    @supportTeethBottomLength.setter
    def supportTeethBottomLength(self, bottomLength: float):
        self._supportTeethBottomLength = bottomLength

    @property
    def supportTeethBaseInterval(self) -> float:
        """
        The gap between the base of the tooth.
        """
        return self._supportTeethBaseInterval

    @supportTeethBaseInterval.setter
    def supportTeethBaseInterval(self, baseInterval: float):
        self._supportTeethBaseInterval = baseInterval

    @property
    def supportTeethUpperPenetration(self) -> float:
        """
        Vertical (:math:`+Z`) penetration of the support teeth into the intersecting part mesh.
        """
        return self._supportTeethUpperPenetration

    @supportTeethUpperPenetration.setter
    def supportTeethUpperPenetration(self, distance: float):
        self._supportTeethUpperPenetration = distance

    @property
    def mergeMesh(self) -> bool:
        """
        Determines if the support truss geometry should be merged together into a connected unified mesh"
        """
        return self._mergeMesh

    @mergeMesh.setter
    def mergeMesh(self, state: bool):
        self._mergeMesh = state

    @property
    def useSupportSkin(self) -> bool:
        """ Generates a support skin around the extruded boundary of the support"""
        return self._useSupportSkin

    @useSupportSkin.setter
    def useSupportSkin(self, value):
        self._useSupportSkin = value

    @property
    def useSupportBorder(self) -> bool:
        """ Generates a border around the each truss grid """
        return self._useSupportBorder

    @useSupportBorder.setter
    def useSupportBorder(self, value: bool):
        self._useSupportBorder = value

    @property
    def trussWidth(self) -> float:
        """
        The width of a strut in the truss network
        """
        return self._trussWidth

    @trussWidth.setter
    def trussWidth(self, width: float):
        self._trussWidth = width

    @property
    def generateTrussGrid(self) -> bool:
        """
        Set to ``True`` to generate the truss grid, otherwise the support volume.
        """
        return self._generateTrussGrid

    @generateTrussGrid.setter
    def generateTrussGrid(self, state: bool):
        self._generateTrussGrid = state

    @property
    def supportBorderDistance(self) -> float:
        """
        The offset used when generating a border or support skin for each truss slice in the support block.
        """
        return self._supportBorderDistance

    @supportBorderDistance.setter
    def supportBorderDistance(self, distance: float):
        self._supportBorderDistance = distance

    @property
    def trussAngle(self) -> float:
        """
        The angle (degrees) used for generating the truss structures used in the support structure.
        """
        return self._trussAngle

    @trussAngle.setter
    def trussAngle(self, angle: float):
        self._trussAngle = angle

    @property
    def gridSpacing(self) -> List[float]:
        """
        The spacing of the grid truss structure within the block support .
        """
        return self._gridSpacing

    @gridSpacing.setter
    def gridSpacing(self, spacing: List[float]):
        """
        The Grid spacing used for the support structure.
        """
        self._gridSpacing = spacing

    @staticmethod
    def holeGeometry():
        """ Depreciated function """
        return Polygon([[-1.5, 0], [0, 1.], [1.5, 0], [0, -1.0], [-1.5, 0]])

    @staticmethod
    def clipLines(paths: Any, lines: np.ndarray) -> List[np.ndarray]:
        """
        Clips a series of lines (hatches) across a closed polygon or set of paths. It is an overloaded function for
        internally clipping hatches according to a pyclipr supported path.

        :param paths: The set of boundary paths for trimming the lines
        :param lines: The un-trimmed lines to clip from the boundary
        :return: A list of trimmed lines (open paths)
        """

        pc = pyclipr.Clipper()
        pc.scaleFactor = int(BaseHatcher.CLIPPER_SCALEFACTOR)

        pc.addPaths(lines.reshape(-1, 2, 3), pyclipr.Subject, True)
        pc.addPaths(paths, pyclipr.Clip, False)
        out = pc.execute(pyclipr.Intersection, pyclipr.FillRule.NonZero, returnOpenPaths=True, returnZ=False)
        lineXY = np.array(out[1])

        return lineXY

    @staticmethod
    def generateMeshGrid(poly: shapely.geometry.polygon.Polygon,
                         hatchSpacing: Optional[float] = 5.0,
                         hatchAngle: Optional[float] = 45.0) -> np.ndarray:
        """
        Generates a grid mesh i.e. a series of hatches to fill a polygon region in order to generate a truss network
        used as part of a support truss structure. The mesh grid is offset to create the truss.

        The polygon bounding box of the Shapley Polygon is generated, and the a hatch grid
        with a separation distance of `hatchSpacing` is generated to guarantee filling this bounding box region at
        any required `hatchAngle`.

        :param poly: A Shapley Polygon consisting of a polygon or path to fill with hatches
        :param hatchSpacing: The hatch spacing using to generate the truss network
        :param hatchAngle: The hatch angle to generate truss network with
        :return: The hatch lines that completely fills the geometry
        """

        # Hatch angle
        theta_h = np.radians(hatchAngle)  # 'rad'

        # Get the bounding box of the paths
        bbox = np.array(poly.bounds)

        # Expand the bounding box
        bboxCentre = np.mean(bbox.reshape(2, 2), axis=0)

        # Calculates the diagonal length for which is the longest
        diagonal = bbox[2:] - bboxCentre
        bboxRadius = np.ceil(np.sqrt(diagonal.dot(diagonal)) / hatchSpacing) * hatchSpacing

        # Construct a square which wraps the radius
        x = np.tile(np.arange(-bboxRadius, bboxRadius, hatchSpacing, dtype=np.float32).reshape(-1, 1), (2)).flatten()
        y = np.array([-bboxRadius, bboxRadius])
        y = np.resize(y, x.shape)
        z = np.arange(0, x.shape[0] / 2, 0.5).astype(np.int64)

        coords = np.hstack([x.reshape(-1, 1),
                            y.reshape(-1, 1),
                            z.reshape(-1, 1)])

        # Create the 2D rotation matrix with an additional row, column to preserve the hatch order
        c, s = np.cos(theta_h), np.sin(theta_h)
        R = np.array([(c, -s, 0),
                      (s, c, 0),
                      (0, 0, 1.0)])

        # Apply the rotation matrix and translate to bounding box centre
        coords = np.matmul(R, coords.T)
        coords = coords.T + np.hstack([bboxCentre, 0.0])

        return coords

    @property
    def borderGeometry(self):
        """
        The support skin (around the boundary) for the support volume
        """
        return self.generateSupportSkins()

    @property
    def sliceGeometry(self):
        """
        The grid composed of trusses in both the X and Y orientations.
        """
        slicesX, slicesY = self.generateSupportSlices()

        return slicesX, slicesY

    def geometry(self) -> trimesh.Trimesh:
        """
        The geometry for the support structure. This resolve the  entire connectivity of the support truss
        meshes used by performing a boolean Union operation on the collection of meshes generated when the
        attribute :attr:`mergeMesh` option is set :code:`True`. Otherwise, the truss structure is merged
        as overlapping and non-connected meshes into a single :class:`trimesh.Trimesh` mesh..

        :return: The support geometry mesh
        """

        logging.info('Generating Mesh Geometry for GridBlock Support')
        logging.info('\tGenerating support grid slices')
        slicesX, slicesY = self.generateSupportSlices()
        logging.info('\tGenerating support border')

        if self.useSupportSkin:
            supportSkins = self.generateSupportSkins()
        else:
            supportSkins = []

        # Use the Cork library to merge meshes
        if self._mergeMesh:

            raise Exception('Currently performing a boolean merge between shell meshes is not available - please use the non-merged mesh')

            logging.info('\t - Resolving Boolean Intersections between all support meshes')
            # Intersect the projection of the support face with the original part using the Cork Library

            isectMesh = slicesX + slicesY

            if len(isectMesh.faces) > 0:
                isectMesh = resolveIntersection(isectMesh)

            isectMesh += supportSkins
        else:
            logging.info('\t Concatenating Support Geometry Meshes Together')
            maxId = np.max(slicesY.face_attributes.get('order', 0)) + 1

            # Update the scan order index for each boundary located on the support
            for i in range(len(supportSkins)):
                supportSkins[i].face_attributes['order'] = np.ones(len(supportSkins[i].faces)) * (maxId + i)
                supportSkins[i].face_attributes['type'] = np.ones(len(supportSkins[i].faces)) * GridMeshType.BOUNDARY

            # Concatenate the meshes including the stored face attributes
            isectMesh = self.concatenateMeshes([slicesX, slicesY] + supportSkins)

        # Assign a random colour to the support geometry generated
        isectMesh.visual.face_colors[:, :3] = np.random.randint(254, size=3)
        return isectMesh

    def generateSliceBoundingBoxPolygon(self, section: trimesh.path.Path2D) -> shapely.geometry.Polygon:
        """
        Generates an equivalent 2D Polygon bounding box of the support geometry volume transformed correctly into the
        local coordinate system of each grid slice by inversion of the internally stored transformation matrix in
        :class:`trimesh.path.Path2D`. This provides a consistent centroid or local origin for generating the truss
        frame across the entire support volume.

        :param section: A trimesh `Path2D` cross-section consisting of a 3D transformation matrix
        :return: A 2D polygon representing the bounding box of the support geometry volume.
        """

        supportGeom = self._supportVolume
        sliceTransform = section[1]
        #bbox = np.dot(np.linalg.inv(section.metadata['to_3D'][:3, :3]), supportGeom.bounds.T).T
        bbox = np.dot(np.linalg.inv(sliceTransform[:3, :3]), supportGeom.bounds.T).T

        bx = bbox[:, 0]
        by = bbox[:, 1]
        bz = bbox[:, 2]

        a = [np.min(bx), np.max(bx)]
        b = [np.min(by), np.max(by)]

        # Create a closed polygon representing the transformed slice geometry
        bboxPoly = Polygon([[a[0], b[0]],
                            [a[0], b[1]],
                            [a[1], b[1]],
                            [a[1], b[0]],
                            [a[0], b[0]]])

        return bboxPoly

    def toothProfile(self) -> np.array:
        """
        The 2D profile of a tooth used along the edge profile when generating the profile for the skin and
        the planar truss structure. This can be overriden in a derived class to provide a custom pattern or design of
        tooth for use along the profile of the support generation.
        """

        p_a = self._supportTeethHeight
        p_b = self._supportTeethTopLength
        p_c = self._supportTeethBottomLength
        p_d = self._supportTeethBaseInterval

        # Generate a pattern
        toothPattern = [(0.0, 0.0),
                        ((p_c - p_b) / 2.0, p_a),
                        ((p_c - p_b) / 2.0 + p_b, p_a),
                        (p_c, 0.0),
                        (p_c + p_d, 0.0)]

        toothPattern = np.array(toothPattern)

        """
        Offset the pattern using the tooth height parameter with the additional upper penetration distance into the part
        """
        toothPattern[:, 1] -= p_a
        toothPattern[:, 1] += self._supportTeethUpperPenetration
        return toothPattern

    def generateSliceGeometry(self, section: trimesh.path.Path2D):
        """
        Generates a truss grid used as a 2D slice used for generating a section as part of a support structures.

        :param section: The polygon section of slice through the geometry
        :return: A Trimesh Path2D object of the truss geometry
        """

        if section[0].shape[0] == 0:
            return None

        sin_theta = getFaceZProjectionWeight(self._supportVolume, useConnectivity=False)

        topIdx = np.argwhere(sin_theta < BlockSupportGenerator._supportSkinSideTolerance)

        newIdx = section[2]
        fndIdx = np.isin(newIdx,topIdx, invert=False)
        sideIdx = np.invert(fndIdx)

        segs = section[0]  # [fndIdx]
        unique, inverse = trimesh.grouping.unique_rows(segs.reshape(-1, 2), digits=4)
        out = trimesh.path.exchange.misc.edges_to_path(edges=inverse.reshape((-1, 2)),
                                                       vertices=segs.reshape(-1, 2)[unique])
        ad = trimesh.load_path(out)
        paths = ad.discrete
        slicePaths = []

        """
        Multiple polygon intersection may be generated and require processing separately
        """

        offsetPaths = []

        for path in paths:

            coords = np.hstack([path,np.roll(path,-1,axis=0)]).reshape(-1, 2, 2)[:-1]

            """
            Identify the upper and lower edges of the polygon. This is guaranteed for extruded supports because the
            sides edges are always vertically orientated in (:math:`+Z`). Also note order is sequentially guaranteed since
            the polygons edges have been pre-sorted and correctly orientated.
            """

            idx = np.abs(np.diff(coords, axis=1).reshape(-1, 2)[:,1]) > 1e-4
            splitIdx = np.split(np.arange(0, len(idx)), np.argwhere(np.diff(idx)).ravel()+1)
            partsIdx = np.argwhere(np.array([np.any(idx[split]) for split in splitIdx])) # Locate only masked edges

            newPaths = []

            upperPaths = []
            lowerPaths = []

            """ Iterate through the identified upper and lower edges found """
            for segIdx in partsIdx:

                sid = int(segIdx)

                seg = np.vstack([coords[splitIdx[sid]][:, 0, :],
                                 coords[splitIdx[sid]][-1, 1, :]])
                ps = trimesh.path.traversal.PathSample(seg)

                """
                The bottom vertex of the path is lower than top indicates (counter-clockwise) when
                the polygon has its paths correctly sorted internally using pyclipr or Shapely. This orientation 
                gives an indication if the geometry lies at the top or the bottom of the support volume
                """
                isccw = seg[-1, 1] < seg[0, 1]
                dir = -1.0 if isccw else 1.0

                repPattern = self.toothProfile()

                patternLen = repPattern[-1, 0]

                numCycles = int(np.ceil(ps.length / patternLen))
                patternList = []

                for i in range(numCycles):
                    tPattern = repPattern.copy()
                    tPattern[:, 0] += patternLen * i
                    patternList.append(tPattern)

                patternList = np.vstack(patternList)

                """
                Clip the interpolate positions. Trimesh PathSampler clips and repeats values, therefore only unique
                values are selected and used for generating the teeth profile
                """
                xPos, idx = np.unique(np.clip(patternList[:, 0], 0, ps.length), return_index=True)
                teethFinal = ps.sample(xPos)

                teethFinal[:, 0] += dir * patternList[idx, 1]

                """
                If the number of teeth profiles is beyond the length of the support edge, then exclude the use of a 
                tooth and use the original edge
                """
                if numCycles == 1:
                    teethFinal = seg

                # Prevent the generation of lower or upper support teeth
                if not self._useLowerSupportTeeth and dir > 0:
                    teethFinal = seg

                if dir > 0:
                    lowerPaths.append(teethFinal)

                # Prevent the generation of lower support teeth
                if not self._useUpperSupportTeeth and dir < 0:
                    teethFinal = seg

                if dir < 0:
                    upperPaths.append(teethFinal)

                newPaths.append(teethFinal)

            nPaths = np.vstack(newPaths)
            nPaths = np.vstack([nPaths, nPaths[0,:]])
            nPathPoly = shapely.geometry.Polygon(nPaths).buffer(1e-5)
            slicePaths.append(nPathPoly)

            """
            Add additional support to the upper and lower surfaces 
            """
            if self._supportWallThickness > 1e-5:

                if len(upperPaths) == 0 or len(lowerPaths) == 0:
                    continue

                topPolyVerts2, bottomPolyVerts2 = upperPaths[0].copy(), lowerPaths[0].copy()

                topPolyVerts2 = np.vstack([topPolyVerts2[0, :],
                                           topPolyVerts2,
                                           topPolyVerts2[-1, :],
                                           topPolyVerts2[0, :]])
                topPolyVerts2[[0, -1, -2], [0, 0, 0]] = np.min(topPolyVerts2[:, 0]) - 10.0

                bottomPolyVerts2 = np.vstack([bottomPolyVerts2[0, :],
                                              bottomPolyVerts2,
                                              bottomPolyVerts2[-1, :],
                                              bottomPolyVerts2[0, :]])
                bottomPolyVerts2[[0, -1, -2], [0, 0, 0]] = np.max(bottomPolyVerts2[:, 0]) + 10.0

                isectPolyA = shapely.geometry.Polygon(bottomPolyVerts2)  # bottom edge
                isectPolyB = shapely.geometry.Polygon(topPolyVerts2)  # top edge

                # Merge the polygon sections together and offset the boundary
                try:
                    offsetWalls = isectPolyB.buffer(1e-8).union(isectPolyA.buffer(1e-8)).buffer(self._supportWallThickness)
                    isectPolyC = offsetWalls.intersection(nPathPoly)

                    # Identify only geometry which is a polygon/multipolygon
                    if isinstance(isectPolyC, shapely.geometry.GeometryCollection):
                        fndPolys = []
                        for poly in isectPolyC.geoms:
                            if isinstance(poly, shapely.geometry.Polygon) or isinstance(poly, shapely.geometry.MultiPolygon):
                                fndPolys.append(poly)

                        offsetPaths += fndPolys
                    else:
                        offsetPaths.append(isectPolyC)
                except:
                    continue

        polys = slicePaths

        if len(polys) == 0:
            return None

        """
        Obtain the bounding box of the geometry and then transform this to local slice coordinate system. This is needed
        to ensure that the X and Y slice grids correctly align when the are eventually put together. It is achieved by
        ensuring the centroid of the support volume is used as a consistent origin in both coordinate systems.
        This transforms the support geometry based on the transformation matrix and the original bounds.
        """

        bboxPoly = self.generateSliceBoundingBoxPolygon(section)

        """
        In order to improve performance we resort to using pyclipr rather than Shapely library routines, as from
        experience this tends to perform slowly during clipping and offset operations, despite a more convenient
        API.
        """

        # Convert the shapley polygons to a path list
        convPolys = []
        for poly in polys:
            if isinstance(poly, shapely.geometry.MultiPolygon):
                convPolys += poly.geoms
            else:
                convPolys.append(poly)
        paths = path2DToPathList(convPolys)

        pc = pyclipr.ClipperOffset()
        pc.scaleFactor = int(BaseHatcher.CLIPPER_SCALEFACTOR)

        pc.addPaths(paths, pyclipr.JoinType.Square, pyclipr.EndType.Polygon)

        if not self._generateTrussGrid:
            """
            Only generate the polygon section. This requires processing within pyclipr to process each path
            into the correct order.
            """

            # Perform the offseting operation
            outerPaths = pc.execute(10. / BaseHatcher.CLIPPER_SCALEFACTOR)

            return outerPaths

        else:
            outerPaths = pc.execute(10. / BaseHatcher.CLIPPER_SCALEFACTOR)

            # Offset the outer boundary to generate the interior boundary
            pc.clear()
            pc.addPaths(paths, pyclipr.JoinType.Round, pyclipr.EndType.Polygon)
            offsetPathInner = pc.execute(-self._supportBorderDistance)

        if len(offsetPathInner) < 1:
            return None

        diag = self._gridSpacing[0] * np.sin(np.deg2rad(self._trussAngle))

        # Generate the mesh grid used for the support trusses and merge the lines together
        hatchesA = self.generateMeshGrid(bboxPoly, hatchAngle=self._trussAngle, hatchSpacing=diag).reshape(-1, 2, 3)
        hatchesB = self.generateMeshGrid(bboxPoly, hatchAngle=180 - self._trussAngle, hatchSpacing=diag).reshape(-1, 2, 3)
        hatches = np.vstack([hatchesA, hatchesB])

        """
        We clip the truss hatches to remove any that are outside of the boundary in order to remove any elements which
        are not relevant to the structure in order to improve performance later
        """
        hatches2 = self.clipLines(outerPaths, hatches)

        """
        Offset the hatches to form a truss structure
        """
        pc.clear()
        pc.addPaths(hatches2, pyclipr.JoinType.Square, pyclipr.EndType.Joined)
        trussPaths = pc.execute(self._trussWidth / 2.0)

        """
        Clip or trim the Truss Paths with the exterior of the support slice boundary
        """
        pc2 = pyclipr.Clipper()
        pc2.addPaths(trussPaths, pyclipr.Subject, False)
        pc2.addPaths(outerPaths, pyclipr.Clip, False)

        solution = pc2.execute(pyclipr.Intersection, pyclipr.FillRule.NonZero, returnOpenPaths=False)

        if self._supportWallThickness > 1e-5:

            pc2.clear()
            pc2.addPaths(solution, pyclipr.Clip)

            clippingPaths = []
            for mPoly in offsetPaths:
                clippingPaths += hatchingUtils.poly2Paths(mPoly)

            pc2.addPaths(clippingPaths, pyclipr.Subject, False)

            # Note open paths (lines) have to used pyclipr::Execute2 in order to perform trimming
            solution = pc2.execute(pyclipr.Union)

        if self._useSupportBorder:
            """
            Generate the support skin
            """
            pc2.clear()
            pc2.addPaths(outerPaths, pyclipr.Subject, False)
            pc2.addPaths(offsetPathInner,  pyclipr.Clip, False)
            skinSolutionPaths = pc2.execute(pyclipr.Difference, returnOpenPaths=False, returnZ=False)

            """
            Merge all the paths together
            """
            pc2.clear()
            pc2.addPaths(solution, pyclipr.Subject, False)
            pc2.addPaths(skinSolutionPaths, pyclipr.Clip, False)
            solution = pc2.execute2(pyclipr.Union)
        else:
            pc2.clear()
            pc2.addPaths(solution, pyclipr.Subject, False)
            solution = pc2.execute2(pyclipr.Union)

        return solution

    def generateSliceGeometryDepr(self, section):
        """
        Exists as a reference to how this can be performed using Shapely.Geometry.Polygon Objects

        :param section:
        :return:
        """

        if not section:
            return trimesh.path.Path2D()

        polys = section.polygons_closed

        if len(polys) == 0:
            return trimesh.path.Path2D()

        supportShapes = []

        for poly in polys:

            sliceBBox = poly.bounds

            if True:
                hole = self.holeGeometry()

                holes = []
                i = 1
                for x in np.arange(sliceBBox[0], sliceBBox[2], 2.25):
                    i += 1
                    for y in np.arange(sliceBBox[1], sliceBBox[3], 3):
                        y2 = y
                        if i % 2:
                            holes.append(shapely.affinity.translate(hole, x, y2))
                        else:
                            holes.append(shapely.affinity.translate(hole, x, y2 + 1.5))

                union_holes = shapely.ops.unary_union(holes)

                section_holes = poly.difference(union_holes)
            else:
                section_holes = poly.difference(poly.buffer(-self._supportBorderDistance))

            if self._useSupportBorder:
                support_border = poly.difference(poly.buffer(-self._supportBorderDistance))
                supportShape = support_border.union(section_holes)
            else:
                supportShape = section_holes

            supportShapes.append(supportShape)

        # Merge the Support Geometry
        # sliceGeometry = shapely.ops.unary_union(supportShapes)

        loadedPaths = [trimesh.path.exchange.load.load_path(path) for path in list(supportShapes)]
        sectionPath = trimesh.path.util.concatenate(loadedPaths)

        return sectionPath

    def generateSupportSkinInfill(self, myPolyVerts: np.ndarray,
                                  returnPolyNodes: Optional[bool] =False) -> Tuple[np.ndarray, np.ndarray]:
        """
        Generates a standard truss grid infill for a support border boundary  has been previously
        flattened prior to applying a 'wrapping' transformation projecting the 2D skin into the 3D support

        :param myPolyVerts: A single boundary of coordinates representing the
        :return: A mesh (vertices, faces) of the triangulated truss support order.
        """
        pc = pyclipr.ClipperOffset()
        pc.scaleFactor = BaseHatcher.CLIPPER_SCALEFACTOR
        # Offset the outer path to provide a clean boundary to work with
        #paths2 = np.hstack([myPolyVerts, np.arange(len(myPolyVerts)).reshape(-1, 1)])
        #paths2 = list(map(tuple, paths2))
        #clipPaths = BaseHatcher.scaleToClipper(paths2)

        """
        Offset the paths interior
        """
        pc.addPath(myPolyVerts, pyclipr.JoinType.Square, pyclipr.EndType.Polygon)

        if not self._generateTrussGrid:
            """
            Only generate the polygon section. This requires processing within pyclipr to process each path
            into the correct order.
            """
            outerPaths = pc.execute2(10. / BaseHatcher.CLIPPER_SCALEFACTOR)

            # Process the paths and create valid path rings to form a polygon for triangulation
            exterior, interior = sortExteriorInteriorRings(outerPaths, closePolygon=True)

            # Triangulate the surface for re-mapping the mesh to the boundary
            vy, fy = triangulatePolygonFromPaths(exterior[0], interior, triangle_args='pa{:.3f}'.format(2.0))

            return vy, fy
        else:
            outerPaths = pc.execute(10. / BaseHatcher.CLIPPER_SCALEFACTOR)

        # Offset the outer boundary to make the outside
        pc.clear()

        pc.addPaths(outerPaths, pyclipr.JoinType.Round, pyclipr.EndType.Polygon)
        offsetPathInner = pc.execute(-self._supportBorderDistance)

        diag = self._gridSpacing[0] * np.sin(np.deg2rad(self._trussAngle))

        a = [np.min(myPolyVerts[:, 0]), np.max(myPolyVerts[:, 0])]
        b = [np.min(myPolyVerts[:, 1]), np.max(myPolyVerts[:, 1])]

        # Create a closed polygon representing the transformed slice geometry
        bboxPoly = Polygon([[a[0], b[0]],
                            [a[0], b[1]],
                            [a[1], b[1]],
                            [a[1], b[0]], [a[0], b[0]]])

        """
        Generate the mesh grid used for the support trusses and merge the lines together
        """
        hatchesA = self.generateMeshGrid(bboxPoly, hatchSpacing=diag, hatchAngle=self._trussAngle).reshape(-1, 2, 3)
        hatchesB = self.generateMeshGrid(bboxPoly, hatchSpacing=diag, hatchAngle=180 - self._trussAngle).reshape(-1, 2, 3)
        hatches = np.vstack([hatchesA, hatchesB])

        """
        Generate the truss by expanding the lines accordingly
        """
        pc.clear()

        pc.addPaths(hatches, pyclipr.JoinType.Square, pyclipr.EndType.Joined)
        trussPaths = pc.execute(self._trussWidth / 2.0)

        """
        Clip or trim the Truss Paths with the exterior of the support slice boundary
        """
        pc2 = pyclipr.Clipper()

        if self._useSupportBorder and len(offsetPathInner) > 0:

            pc2.addPaths(trussPaths, pyclipr.Subject)
            pc2.addPaths(outerPaths, pyclipr.Clip)

            trimmedTrussPaths = pc2.execute(pyclipr.Intersection)

            """
            Generate the support skin
            """
            pc2.clear()
            pc2.addPaths(outerPaths, pyclipr.Subject)
            pc2.addPaths(offsetPathInner, pyclipr.Clip)
            skinSolutionPaths = pc2.execute(pyclipr.Difference)

            """
            Merge all the paths together
            """
            pc2.clear()
            pc2.addPaths(trimmedTrussPaths, pyclipr.Subject)
            pc2.addPaths(skinSolutionPaths, pyclipr.Clip)

            if returnPolyNodes:
                solution = pc2.execute2(pyclipr.Union)
            else:
                solution = pc2.execute(pyclipr.Union)
        else:
            # Use only the truss paths. This simply exports ClipperLib PolyNode Tree
            pc2.addPaths(trussPaths, pyclipr.Subject)
            pc2.addPaths(outerPaths, pyclipr.Clip)

            if returnPolyNodes:
                solution = pc2.execute2(pyclipr.Intersection, pyclipr.FillRule.NonZero)
            else:
                solution = pc2.execute(pyclipr.Intersection, pyclipr.FillRule.NonZero)

        # vy, fy = geometry.triangulatePolygon(bufferPoly)

        # Triangulate the polygon - kept as a reference as an alternative

        # pyslm.visualise.plotPolygon(bufferPoly)
        # simpPolys = pyclipper.SimplifyPolygons(solution)
        # vy, fy = bufferPoly.triangulate(engine='earcut')

        # poly = Polygon(tuple(map(tuple, exterior[0])), holes=[tuple(map(tuple, ring))for ring in interior])

        # vy, fy =  pyslm.support.geometry.triangulateShapelyPolygon(poly, triangle_args='pa{:.3f}'.format(4.0))
        #vy, fy = pyslm.support.geometry.triangulatePolygonFromPaths(exterior[0], interior,
        #                                                            triangle_args='pa{:.3f}'.format(4.0))
        # vy, fy = bufferPoly.triangulate(triangle_args='pa{:.3f}'.format(4.0))
        # wvy, fy = triangulatePolygon(solution, closed=False)
        #return vy, fy

        return solution

    def generateSupportSkins(self) -> trimesh.Trimesh:
        """
        Generates the border or boundary wall of a block support structure with a truss structure for perforations for
        material removal.

        :return: A :class:`trimesh.Trimesh` object containing the mesh  of the generated support boundary
        """
        blockSupportMesh = self.supportVolume

        """
        Extract the top and bottom surfaces of the mesh that are perpendicular to the z direction
        """
        blockSupportSides = blockSupportMesh.copy()
        blockSupportSides.fix_normals()
        blockSupportSides.merge_vertices(digits_vertex=3)
        sin_theta = getFaceZProjectionWeight(blockSupportSides, useConnectivity=False)

        # First mask removes very small faces
        # Second mask isolates the outside region
        mask = blockSupportSides.area_faces > 1e-6
        mask2 = sin_theta < BlockSupportGenerator._supportSkinSideTolerance
        mask3 = np.logical_and(mask, mask2)
        blockSupportSides.update_faces(mask3)

        # Split the top and bottom surfaces to a path - guaranteed to be a manifold 2D polygon
        supportSurfCpy = blockSupportSides.split(only_watertight=False)

        supportSurf = []
        for surf in supportSurfCpy:
            if surf.area > 5:
                supportSurf.append(surf)

        if len(supportSurf) < 2:
            return []

        if len(supportSurf) > 2:

            # Uncomment below to identify issues with support generation
            #blockSupportSides.show()
            warnings.warn('Warning: number of isolated curves')
            return []

        (top, bottom) = (supportSurf[0], supportSurf[1])

        """
        Swap the curves based on their overall position in their z-position for the support structure boundary.
        Semantically this makes no difference to the generation of the support structure.
        """
        if bottom.bounds[1, 2] > top.bounds[1, 2]:
            top, bottom = bottom, top

        topPoly3D = top.outline()
        bottomPoly3D = bottom.outline()

        topPoly3D.merge_vertices(3)
        bottomPoly3D.merge_vertices(3)

        topPoly2D = topPoly3D.copy()
        bottomPoly2D = bottomPoly3D.copy()
        topPoly2D.vertices[:, 2] = 0
        bottomPoly2D.vertices[:, 2] = 0

        # Calculate the distance of the loops using the 2D (XY) Projection
        topPathLengths = [ent.length(topPoly2D.vertices) for ent in topPoly2D.entities]
        bottomPathLengths = [ent.length(bottomPoly2D.vertices) for ent in bottomPoly2D.entities]

        pairTolerance = 0.1

        pairs = []
        for i, topPath in enumerate(topPoly3D.paths):
            pathLen = sum([topPathLengths[pid] for pid in topPath])
            for j, bottomPath in enumerate(bottomPoly3D.paths):
                botPathLen = sum([bottomPathLengths[pid] for pid in bottomPath])

                if np.abs(pathLen - botPathLen) / botPathLen < pairTolerance:
                    pairs.append((i, j))

        # remove isolated edges in poly
        if len(pairs) < 1:

            # Uncomment to visualise the support if there any issues with the support generation
            #blockSupportSides.show()
            return []

        topPaths = topPoly3D.paths
        bottomPaths = bottomPoly3D.paths

        if len(topPoly3D.paths) != len(bottomPoly3D.paths):
            blockSupportSides.show()
            # print('numer of paths between top and bottom do not match', len(topPoly3D.paths) , len(bottomPoly3D.paths))
            logging.warning('Number of paths between top and bottom of support structure do not match - skipping')
            return []

        boundaryMeshList = []

        for pair in pairs:

            topVerts = trimesh.path.traversal.discretize_path(topPoly3D.entities, topPoly3D.vertices, topPoly3D.paths[pair[0]])
            topPoly3Dcpy = topPoly3D.copy()
            topPoly3Dcpy.vertices[:, 2] = 0.0

            topXY = topVerts[:, :2]
            topZ = topVerts[:, 2]

            """ Ensure that the Polygon orientation is consistent in a CW fashion.  """
            if not pyclipr.orientation(topXY):
                topXY = np.flipud(topXY)
                topZ = np.flip(topZ)

            # Record the start position of the first curve for use later
            topStartPos = topXY[0]

            # topXY2 = np.vstack([topXY, topXY[0, :]])
            delta = np.diff(topXY, prepend=topXY[0, :].reshape(1, -1), axis=0)
            dist = np.sqrt(delta[:, 0] * delta[:, 0] + delta[:, 1] * delta[:, 1])

            topPolyX = np.cumsum(dist)
            topPolyY = topZ

            topPolyVerts = np.hstack([topPolyX.reshape(-1, 1), topPolyY.reshape(-1, 1)])

            """
            Complete the bottom section of the support boundary
            """
            bottomPoly3Dcpy = bottomPoly3D.copy()
            bottomPoly3Dcpy.vertices[:, 2] = 0.0

            bottomVerts = trimesh.path.traversal.discretize_path(bottomPoly3D.entities, bottomPoly3D.vertices,
                                                                 bottomPoly3D.paths[pair[1]])

            bottomXY = bottomVerts[:, :2]
            bottomZ = bottomVerts[:, 2]

            """
            The Polygon order or orientation has to be consistent with the top curve, since this is not guaranteed
            automatically by Trimesh. If the orientations are not consistent between the top and b  ottom curve both the
            (XY,Z) coordinates are flipped.
            """
            if not (pyclipr.orientation(topXY) and pyclipr.orientation(bottomXY)):
                bottomXY = np.flip(bottomXY, axis=0)
                bottomZ = np.flip(bottomZ, axis=0)

            """
            The starting pint of the curves are arbitrary set by Trimesh. We use the start point of the previous curve to
            identify the point.

            Iterate through all the points in the second curve and  find the closest point to the start index in the
            previous curve based on the distance. The coordinates (both XY, Z) are moved using numpy.roll to move the
            starting point of the curves as close to each other.
            """
            dist = bottomXY - topStartPos
            dist = np.sqrt(dist[:, 0] * dist[:, 0] + dist[:, 1] * dist[:, 1])
            startId = np.argmin(dist)
            bottomXY = np.roll(bottomXY, -startId, axis=0)
            bottomZ = np.roll(bottomZ, -startId, axis=0)

            bottomXY2 = np.vstack([bottomXY, bottomXY[0, :]])
            bottomZ = np.append(bottomZ, bottomZ[0])
            delta = np.diff(bottomXY2, prepend=bottomXY2[0, :].reshape(1, -1), axis=0)
            dist = np.sqrt(delta[:, 0] * delta[:, 0] + delta[:, 1] * delta[:, 1])

            bottomPolyX = np.cumsum(dist)
            bottomPolyY = bottomZ
            bottomPolyVerts = np.hstack([bottomPolyX.reshape(-1, 1), bottomPolyY.reshape(-1, 1)])
            bottomPolyVerts = np.flip(bottomPolyVerts, axis=0)

            """
            Form the polygon for the support boundary
            """
            if self._useLowerSupportTeeth:
                # Provide a path interpolator to resample the teeth across the profile
                ps = trimesh.path.traversal.PathSample(bottomPolyVerts)

                # Generate the tooth profile
                repPattern = self.toothProfile()

                patternLen = repPattern[-1, 0]

                numCycles = int(np.ceil(ps.length / patternLen))
                patternList = []

                # Replicate the tooth profile pattern across the entire length of the upper boundary
                for i in range(numCycles):
                    tPattern = repPattern.copy()
                    tPattern[:, 0] += patternLen * i
                    patternList.append(tPattern)

                patternList = np.vstack(patternList)

                """
                Clip the interpolate positions. Trimesh PathSampler clips and repeats values, therefore only unique
                values are selected and used for generating the teeth profile
                """
                xPos, idx = np.unique(np.clip(patternList[:, 0], 0, ps.length), return_index=True)
                teethFinalBottom = ps.sample(xPos)

                #teethFinal = ps.sample(np.clip(patternList[:, 0], 0, ps.length))
                teethFinalBottom[:, 1] += patternList[idx, 1]

            """
            The bottom vertex of the path is lower than top indicates (counter-clockwise) when
            the polygon has its paths correctly sorted internally using pyclipr or Shapely. This orientation 
            gives an indication if the geometry lies at the top or the bottom of the support volume
            """

            if self._useUpperSupportTeeth:

                # Provide a path interpolator to resample the teeth across the profile
                ps = trimesh.path.traversal.PathSample(topPolyVerts)

                repPattern = self.toothProfile()

                patternLen = repPattern[-1, 0]

                numCycles = int(np.ceil(ps.length / patternLen))
                patternList = []

                # Replicate the tooth profile pattern across the entire length of the upper boundary
                for i in range(numCycles):
                    tPattern = repPattern.copy()
                    tPattern[:, 0] += patternLen * i
                    patternList.append(tPattern)

                patternList = np.vstack(patternList)

                """
                Clip the interpolate positions. Trimesh PathSampler clips and repeats values, therefore only unique
                values are selected and used for generating the teeth profile
                """
                xPos, idx = np.unique(np.clip(patternList[:, 0], 0, ps.length), return_index=True)
                teethFinalTop = ps.sample(xPos)

                #teethFinal = ps.sample(np.clip(patternList[:, 0], 0, ps.length))
                teethFinalTop[:, 1] += patternList[idx, 1]

            vertexList = []

            if self._useUpperSupportTeeth:
                vertexList.append(teethFinalTop)
            else:
                vertexList.append(topPolyVerts)

            if self._useLowerSupportTeeth:
                vertexList.append(teethFinalBottom)
            else:
                vertexList.append(bottomPolyVerts)

            # Use the intersecting boundaries of the support volume instead
            myPolyVerts = np.vstack(vertexList)

            """ 
            Resample the boundary
            """
            myPolyVerts = trimesh.path.traversal.resample_path(myPolyVerts, step=0.25)

            """
            Add additional support to the upper and lower surfaces 
            """
            if self._supportWallThickness > 1e-5:

                infillSolution = self.generateSupportSkinInfill(myPolyVerts, returnPolyNodes=False)

                topPolyVerts2, bottomPolyVerts2 = topPolyVerts.copy(), bottomPolyVerts.copy()

                topPolyVerts2 = np.vstack([topPolyVerts2[0, :],
                                           topPolyVerts2,
                                           topPolyVerts2[-1, :],
                                           topPolyVerts2[0, :]])

                topPolyVerts2[[0, -1, -2], [1, 1, 1]] = np.max(topPolyVerts2[:, 1]) + 10.0

                bottomPolyVerts2 = np.vstack([bottomPolyVerts2[0, :],
                                              bottomPolyVerts2,
                                              bottomPolyVerts2[-1, :],
                                              bottomPolyVerts2[0, :]])

                bottomPolyVerts2[[0, -1, -2], [1, 1, 1]] = np.min(bottomPolyVerts2[:, 1]) - 10.0

                isectPolyA = shapely.geometry.Polygon(bottomPolyVerts2) # bottom edge
                isectPolyB = shapely.geometry.Polygon(topPolyVerts2) # top edge

                # Merge the polygon sections together and offset the boundary
                try:
                    offsetWalls = isectPolyB.union(isectPolyA).buffer(self._supportWallThickness)
                    isectPolyC = offsetWalls.intersection(shapely.geometry.Polygon(myPolyVerts))
                except:
                    raise Exception('Error: please share a bug report')

                paths = [np.array(path) for path in infillSolution]
                newPaths = [np.hstack([path, np.arange(len(path)).reshape(-1, 1)]) for path in paths]

                newPaths2 = []
                for path in newPaths:
                    newPaths2.append(np.vstack([path, path[0,:]]))

                ac = [np.array(pol) for pol in hatchingUtils.poly2Paths(isectPolyC)]

                pc = pyclipr.Clipper()
                pc.addPaths(ac, pyclipr.Clip)
                pc.addPaths(newPaths2, pyclipr.Subject)

                # Note open paths (lines) have to used pyclipr::execute2 in order to perform trimming
                result = pc.execute2(pyclipr.Union, pyclipr.FillRule.NonZero)

            else:
                result = self.generateSupportSkinInfill(myPolyVerts, returnPolyNodes=True)

            """
            Create the polygon and triangulate with triangle library to provide a precise controlled conformal mesh.
            """
            exterior, interior = sortExteriorInteriorRings(result, closePolygon=True)

            if len(exterior) < 0:
                import pyslm.visualise
                result2 = self.generateSupportSkinInfill(myPolyVerts, returnPolyNodes=False)
                handle = pyslm.visualise.plotPolygon([myPolyVerts])
                pyslm.visualise.plotPolygon(result2, handle)
                raise Exception('Error: exterior count < 1: Please report bug report')

            if len(exterior) > 1:
                raise Exception('Error: exterior count > 1. Increase the support border distance to resolve this issue. ')

            vy, fy = triangulatePolygonFromPaths(exterior[0], interior, triangle_args='pa{:.3f}'.format(4.0))

            """
            Create the interpolation or mapping function to go from the 2D polygon to the 3D mesh for the support boundary.
            This is done based on the top most projected curve.
            """
            y1 = topXY[:, 0]
            y2 = topXY[:, 1]

            x = np.linspace(0.0, np.max(myPolyVerts[:, 0]), len(y1))
            f1 = interpolate.interp1d(topPolyX, y1, bounds_error=False, fill_value=(topXY[0, 0], topXY[-1, 0]))

            x2 = np.linspace(0.0, np.max(myPolyVerts[:, 0]), len(y2))
            f2 = interpolate.interp1d(topPolyX, y2, bounds_error=False, fill_value=(topXY[0, 1], topXY[-1, 1]))

            vy = np.hstack([vy, np.zeros([len(vy), 1])])

            """
            We subdivide and discretise the mesh further in-order to provide sufficient discretisiation of the support mesh.
            This ensures that the mesh correctly conforms to the boundary of the support block volume - especially at sharp
            apexes or corners.triangulatePo
            """
            tmpMesh = trimesh.Trimesh(vertices=vy, faces=fy, process=True, validate=True)
            tmpMesh.merge_vertices()

            vy, fy = tmpMesh.vertices, tmpMesh.faces

            """
            Subdivide the generated skin mesh to increase the mesh resolution prior to re-mapping the generated 
            2D polygon back to the conforming 3D skin 
            """
            for i in range(self._numSkinMeshSubdivideIterations):
                vy, fy = trimesh.remesh.subdivide(vy, fy)

            """
            Interpolate or map the planar 2D mesh using the existing boundary path to generate the 3D support volume
            """
            boundaryX = f1(vy[:, 0])
            boundaryY = f2(vy[:, 0])
            boundaryZ = vy[:, 1]

            verts = np.hstack([boundaryX.reshape(-1, 1), boundaryY.reshape(-1, 1), boundaryZ.reshape(-1, 1)])
            # Append a z coordinate in order to transform to mesh
            boundaryMesh = trimesh.Trimesh(vertices=verts, faces=fy, process=True)
            boundaryMeshList.append(boundaryMesh)

        return boundaryMeshList

    def generateSupportSlices(self):
        """
        Generates the XY Grid of Support truss slice meshes for generating the interior of each support.

        :return: A tuple of X,Y grid slices
        """
        xSectionMeshList = []
        ySectionMeshList = []

        sectionsX, sectionsY = self.generateGridSlices()

        """
        Note the scanning order begins from zero - boundaries are appended at the end because multiple borders may exist
        """
        scanId = 0


        # Process the Section X
        for i, sectionX in enumerate(sectionsX):

            logging.info('\tX Support generated - {:d}/{:d}'.format(i + 1, len(sectionsX)))
            section = self.generateSliceGeometry(sectionX)

            if section is None:
                continue

            if True:
                # This mode can be a faster performance version

                # poly = Polygon(tuple(map(tuple, exterior[0])), holes=[tuple(map(tuple, ring)) for ring in interior])
                # vy, fy =  pyslm.support.geometry.triangulateShapelyPolygon(poly, triangle_args='pa{:.3f}'.format(4.0))

                vx = []
                fx = []

                idx = 0

                for sect in section.children:
                    exterior, interior = sortExteriorInteriorRings(sect, closePolygon=True)
                    vertsx, facesx = triangulatePolygonFromPaths(exterior[0], interior, triangle_args='pa{:.3f}'.format(4.0))

                    vx.append(vertsx)
                    fx.append(facesx + idx)
                    idx += len(vertsx)

                vx = np.vstack(vx)
                fx = np.vstack(fx)

            else:
                # Triangulate the polygon
                vx, fx = triangulatePolygon(section)

            if len(fx) == 0:
                continue

            # Append a Z coordinate in order to transform to mesh
            vx = np.insert(vx, 2, values=0.0, axis=1)
            secX = trimesh.Trimesh(vertices=vx, faces=fx)

            # Add the scan order to the mesh so that the hatches can be seperated later during slicing
            secX.face_attributes['order'] = np.ones(len(fx)) * scanId
            secX.face_attributes['type'] = np.ones(len(fx)) * GridMeshType.SLICE_X
            scanId += 1

            # Transform using the original transformation matrix generated during slicing
            #secX.apply_transform(sectionX.metadata['to_3D'])
            secX.apply_transform(sectionX[1])
            xSectionMeshList.append(secX)

        logging.info('Compounding X Grid meshes')
        # Concatenate all the truss meshes for the x-slices together in a single pass
        #xSectionMesh = trimesh.util.concatenate(xSectionMeshList)
        xSectionMesh = self.concatenateMeshes(xSectionMeshList)

        # The maximum Id is used for collecting the current scan order
        maxId = len(xSectionMeshList)

        # Process the Section Y
        for i, sectionY in enumerate(sectionsY):

            logging.info('Y Support grid slice generated - {:d}/{:d}'.format(i + 1, len(sectionsY)))

            section = self.generateSliceGeometry(sectionY)

            if section is None:
                continue

            if True:
                # This mode can be a faster performance version

                vy = []
                fy = []

                idx = 0
                for sect in section.children:

                    exterior, interior = sortExteriorInteriorRings(sect, closePolygon=True)
                    vertsy, facesy = triangulatePolygonFromPaths(exterior[0], interior, triangle_args='pa{:.3f}'.format(4.0))
                    vy.append(vertsy)
                    fy.append(facesy + idx)
                    idx += len(vertsy)

                vy = np.vstack(vy)
                fy = np.vstack(fy)

                # poly = Polygon(tuple(map(tuple, exterior[0])), holes=[tuple(map(tuple, ring)) for ring in interior])

                # vy, fy =  pyslm.support.geometry.triangulateShapelyPolygon(poly, triangle_args='pa{:.3f}'.format(4.0))
                # vy, fy = pyslm.support.geometry.triangulate_polygon2(exterior[0], interior,
                #                                                     triangle_args='pa{:.3f}'.format(4.0))
            else:
                # Triangulate the polygon
                vy, fy = triangulatePolygon(section)

            if len(fy) == 0:
                continue

            # Append a z coordinate in order to transform to mesh
            vy = np.insert(vy, 2, values=0.0, axis=1)
            secY = trimesh.Trimesh(vertices=vy, faces=fy)

            # Add the scan order to the mesh so that the hatches can be seperated later during slicing
            secY.face_attributes['order'] = np.ones(len(fy)) * scanId
            secY.face_attributes['type']  = np.ones(len(fy)) * GridMeshType.SLICE_Y

            scanId += 1

            # Transform using the original transformation matrix generated during slicing
            #secY.apply_transform(sectionY.metadata['to_3D'])
            secY.apply_transform(sectionY[1])
            ySectionMeshList.append(secY)

        logging.info('\tCompounding Y Grid meshes')

        # Concatenate all the truss meshes for the y-slices together in a single pass
        ySectionMesh = self.concatenateMeshes(ySectionMeshList)
        return xSectionMesh, ySectionMesh

    def concatenateMeshes(self, meshList):

        if len(meshList) < 1:
            return trimesh.Trimesh()

        idxLen = [len(mesh.vertices) for mesh in meshList]
        idxCumSum = np.hstack([0, np.cumsum(idxLen)])

        newVerts = np.vstack([mesh.vertices for mesh in meshList])
        newFaces = np.vstack([mesh.faces + idxCumSum[i] for i, mesh in enumerate(meshList)])

        faceAttr = {}
        for i, mesh in enumerate(meshList):
            for key, value in mesh.face_attributes.items():
                if key not in faceAttr:
                    faceAttr[key] = []

                faceAttr[key].append(value)

        # Merge the face attributes
        for key, value in faceAttr.items():
            faceAttr[key] = np.hstack(value)

        return trimesh.Trimesh(vertices=newVerts, faces=newFaces, face_attributes=faceAttr, process=False)

    def section_multiplane(self, volume, plane_origin, plane_normal, heights):

        # turn line segments into Path2D/Path3D objects
        from trimesh.exchange.load import load_path
        import trimesh.exchange

        # do a multiplane intersection
        lines, transforms, faces = trimesh.intersections.mesh_multiplane(mesh=volume,
                                                                         plane_normal=plane_normal,
                                                                         plane_origin=plane_origin,
                                                                         heights=heights)

        out = zip(lines, transforms, faces)
        return list(out)

        if False:

            # turn the line segments into Path2D objects
            paths = [None] * len(lines)
            for i, faces, segments, T in zip(range(len(lines)),
                                             faces,
                                             lines,
                                             transforms):
                if len(segments) > 0:
                    paths[i] = load_path(
                        segments,
                        metadata={'to_3D': T, 'face_index': faces})
            return paths

        return lines, transforms, faces

    def generateGridSlices(self) -> Tuple[List[trimesh.path.Path2D], List[trimesh.path.Path2D]]:
        """
        Slices the support volume (:attr:`~BlockSupportBase.supportVolume`) in a grid based on :attr:`gridSpacing`.

        :return: Returns a tuple of the X and Y Grid Slice
        """

        # Obtain the bounding box for the support volume
        supportGeom = self._supportVolume

        bx = supportGeom.bounds[:, 0]
        by = supportGeom.bounds[:, 1]
        bz = supportGeom.bounds[:, 2]

        # Specify the spacing of the support grid slices
        spacingX = self._gridSpacing[0]
        spacingY = self._gridSpacing[1]

        # Obtain the section through the STL extension using Trimesh Algorithm (Shapely)
        midX = (bx[0] + bx[1]) / 2.0
        bottomX = -1.0 * np.ceil((midX - bx[0]) / spacingX) * spacingX
        topX = 1. * np.ceil((bx[1] - midX) / spacingX) * spacingX + 1e-8

        # Generate the support slices of the section
        sectionsX = self.section_multiplane(supportGeom,
                                            plane_origin=[midX, 0.0, 0.0],
                                            plane_normal=[1.0, 0.0, 0.0],
                                            heights=np.arange(bottomX, topX, spacingX))
        midY = (by[0] + by[1]) / 2.0
        bottomY = -1.0 * np.ceil((midY - by[0]) / spacingY) * spacingY
        topY = 1.0 * np.ceil((by[1] - midY) / spacingY) * spacingY + 1e-8

        sectionsY = self.section_multiplane(supportGeom,
                                            plane_origin=[0.0, midY, 0.0],
                                            plane_normal=[0.0, 1.0, 0.0],
                                            heights=np.arange(bottomY, topY, spacingY))

        return sectionsX, sectionsY

    @staticmethod
    def slice(meshSupports: List[trimesh.Trimesh], z: float):
        """
        Slices the Grid Truss Structure including boundaries and the internal truss grid at a given Z position.

        .. note::

            Currently, this is a static member requiring the mesh to be generated prior to slicing. The supports are
            only sorted in the +ve X and Y directions, therefore take care when rotating meshes beyond 45 degrees.

        .. note::
            The scan order is not currently filtered or sorted in a predefined way and will be implemented in the future.

        :param meshSupports: A list of :class:`trimesh.Trimesh` objects
        :return: A tuple of the internal truss grid and the boundary truss grid slices
        """

        # collect the face attributes

        geoms = []
        borderGeoms = []

        for mesh in meshSupports:

            faceOrderIds = []
            cntId = 0

            attrOrder = mesh.face_attributes.get('order', False)
            attrType = mesh.face_attributes.get('type', False)

            if attrOrder is False or attrType is False:
                continue

            # Seperate the mesh types and process independently for convenience
            lines, face_index = trimesh.intersections.mesh_plane(mesh=mesh, plane_normal=[0.0, 0, 1.0],
                                                                 plane_origin=[0, 0, z],
                                                                 return_faces=True)

            # Obtain the order and type ids based on the grid
            orderId = attrOrder[face_index]
            typeId = attrType[face_index]

            """
            Split orderId into arrays based on their order value which were assigned during their generation.
            The direction can be identified by their type id derived from the metadata stored extracted during slicing
            """

            unique, inverse = np.unique(orderId, return_inverse=True)

            bins = np.unique(orderId)
            splitPiece = []

            for i in bins:
                splitPiece.append(np.where(orderId == i)[0])

            """
            Dependent on the type order these in sequential order if part of the grid outline is the first group
            """
            for split in splitPiece:

                # Determine the group type and order appropriately
                if typeId[split[0]] == GridMeshType.BOUNDARY.value:
                    isBorder = True
                else:
                    isBorder = False

                # we know that the boundaries are not co-linear
                coords = lines[split, :, :2]  # .reshape(-1,3)

                if typeId[split[0]] == GridMeshType.SLICE_X.value:
                    # We can assume that the lines are co-linear and can be sorted in ascending order X Value
                    coords = coords.reshape(-1,2)
                    coords = coords[np.argsort(coords[:,1]), :].reshape(-1,2,2)
                    path = trimesh.util.concatenate([trimesh.load_path(c) for c in coords])
                    # [TODO] the above is not the most efficient way to resolve this

                elif typeId[split[0]] == GridMeshType.SLICE_Y.value:
                    # We can assume that the lines are co-linear and can be sorted in ascending order Y Value
                    coords = coords.reshape(-1,2)
                    coords = coords[np.argsort(coords[:,0]), :].reshape(-1,2,2)
                    path = trimesh.util.concatenate([trimesh.load_path(c) for c in coords])

                else:
                    # Load the connected paths (these will merge connected vertices)
                    path = trimesh.load_path(coords, process=False)

                # Convert the entities in the path to a list for re-ordering based on their proximity
                pEnts = path.entities.tolist()

                conPath = []

                p = pEnts.pop(0)
                conPath.append(p)

                """
                Iterate across all connected path entities and identify for each segment type their nearest neighbour
                and switch the ends of the paths to ensure consistent scanning.
                """
                while len(pEnts) > 0:

                    # find the nearest point to the end point
                    vEnd = path.vertices[p.end_points[1]]

                    maxDist = 1e8
                    idxFnd = -1
                    swap = False

                    for j, p2 in enumerate(pEnts):
                        v2Start = path.vertices[p2.end_points[0]]
                        v2End = path.vertices[p2.end_points[1]]
                        # if distance between vStart and vEnd is less than maxDist updated index
                        dist = np.linalg.norm(v2Start - vEnd)
                        dist2 = np.linalg.norm(v2End - vEnd)

                        if dist < maxDist:
                            swap = False
                            maxDist = dist
                            idxFnd = j

                        if dist2 < maxDist:
                            maxDist = dist2
                            swap = True
                            idxFnd = j

                    conPath.append(p)
                    p = pEnts[idxFnd]

                    if swap:
                        p.reverse()

                    pEnts.pop(idxFnd)

                conPath.append(p)

                # Add the ordered connected paths to the output of the slicing either as border or internal grid paths
                for p in conPath:

                    if isBorder:
                        borderGeoms.append(p.discrete(path.vertices))
                    else:
                        geoms.append(p.discrete(path.vertices))

        return geoms, borderGeoms

class GridBlockSupportGenerator(BlockSupportGenerator):
    """
    The GridBlockSupportGenerator class provides common methods used for generating the 'support' structures
    typically used in Metal Additive Manufacturing for block polygon regions. A truss structure is generated that
    provides more efficient scanning of supports of exposure based processes, by minimising exposure jumps.
    """

    def __init__(self):
        super().__init__()

        self._gridSpacing = [3, 3]

        self._useSupportSkin = True
        self._useSupportBorder = True
        self._useLowerSupportTeeth = True
        self._useUpperSupportTeeth = True
        self._numSkinMeshSubdivideIterations = 2

        # Support teeth parameters
        self._supportTeethHeight = 1.5  # mm
        self._supportTeethTopLength = 0.1 # mm
        self._supportTeethBottomLength = 1.5 # mm
        self._supportTeethBaseInterval = 0.2 # mm
        self._supportTeethUpperPenetration = 0.2 # mm
        self._supportWallThickness = 3.0 # mm

        self._mergeMesh = False
        self._supportBorderDistance = 3.0
        self._trussWidth = 1.0
        self._trussAngle = 45

    def __str__(self):
        return 'GridBlockSupportGenerator'

    @property
    def mergeMesh(self) -> bool:
        """
        Determines if the support truss geometry should be merged together into a connected unified mesh
        """
        return self._mergeMesh

    @mergeMesh.setter
    def mergeMesh(self, state: bool):
        self._mergeMesh = state

    @property
    def trussWidth(self) -> float:
        """
        The width of a strut in the truss grid
        """
        return self._trussWidth

    @trussWidth.setter
    def trussWidth(self, width: float):
        self._trussWidth = width

    @property
    def useSupportSkin(self) -> bool:
        """ Generates a truss support skin around the extruded boundary of the support """
        return self._useSupportSkin

    @useSupportSkin.setter
    def useSupportSkin(self, value):
        self._useSupportSkin = value

    @property
    def useSupportBorder(self):
        """ Generates a border around each truss grid """
        return self._useSupportBorder

    @useSupportBorder.setter
    def useSupportBorder(self, value):
        self._useSupportBorder = value

    @property
    def useUpperSupportTeeth(self):
        return self._useUpperSupportTeeth

    @useUpperSupportTeeth.setter
    def useUpperSupportTeeth(self, value):
        self._useUpperSupportTeeth = value

    @property
    def useLowerSupportTeeth(self):
        return self._useUpperSupportTeeth

    @useLowerSupportTeeth.setter
    def useLowerSupportTeeth(self, value):
        self._useLowerSupportTeeth = value
    @property
    def supportBorderDistance(self) -> float:
        """
        The offset used when generating a border or support skin for each truss slice in the support block.
        """
        return self._supportBorderDistance

    @supportBorderDistance.setter
    def supportBorderDistance(self, distance: float):
        self._supportBorderDistance = distance

    @property
    def supportWallThickness(self) -> float:
        return self._supportWallThickness

    @supportWallThickness.setter
    def supportWallThickness(self, wallThickness: float):
        self._supportWallThickness = wallThickness

    @property
    def trussAngle(self) -> float:
        """ The angle (degrees) used for generating the truss structures used in the support structure """
        return self._trussAngle

    @trussAngle.setter
    def trussAngle(self, angle: float):
        self._trussAngle = angle

    @property
    def gridSpacing(self) -> List[float]:
        """ The spacing of the grid truss structure within the block support """
        return self._gridSpacing

    @gridSpacing.setter
    def gridSpacing(self, spacing: List[float]):
        """ The Grid Spacing used for the support structure """
        self._gridSpacing = spacing


    @property
    def supportTeethHeight(self) -> float:
        """
        The height of the perforated support teeth
        """
        return self._supportTeethHeight

    @supportTeethHeight.setter
    def supportTeethHeight(self, teethHeight: float):
        self._supportTeethHeight = teethHeight

    @property
    def supportTeethTopLength(self):
        """
        The upper span or length of the perforated support teeth
        """
        return self._supportTeethTopLength

    @supportTeethTopLength.setter
    def supportTeethTopLength(self, topLength: float):
        self._supportTeethTopLength = topLength

    @property
    def supportTeethBottomLength(self) -> float:
        """
        The bottom span or length of the perforated support teeth
        """
        return self._supportTeethTopLength

    @supportTeethBottomLength.setter
    def supportTeethBottomLength(self, bottomLength: float):
        self._supportTeethBottomLength = bottomLength

    @property
    def supportTeethBaseInterval(self) -> float:
        """
        The gap between the base of the tooth.
        """
        return self._supportTeethBaseInterval

    @supportTeethBaseInterval.setter
    def supportTeethBaseInterval(self, baseInterval: float):
        self._supportTeethBaseInterval = baseInterval

    @property
    def supportTeethUpperPenetration(self) -> float:
        """
        Vertical (:math:`+Z`) penetration of the support teeth into the intersecting mesh
        """
        return self._supportTeethUpperPenetration

    @supportTeethUpperPenetration.setter
    def supportTeethUpperPenetration(self, distance: float):
        self._supportTeethUpperPenetration = distance

    def identifySupportRegions(self, part: Part, overhangAngle: float,
                               findSelfIntersectingSupport: Optional[bool] = True) -> List[GridBlockSupport]:
        """
        Extracts the overhang mesh and generates block regions given a part and target overhang angle. The algorithm
        uses a combination of boolean operations and ray intersection/projection to discriminate support regions.
        If :code:`findSelfIntersectingSupport` is to set :code:`True` (default), the algorithm will process and
        separate overhang regions that by downward projection self-intersect with the part.
        This provides more refined behavior than simply projected support material downwards into larger support
        block regions and separates an overhang surface between intersecting and non-intersecting regions.

        :param part: Part for generating support structures for
        :param overhangAngle: Overhang angle (degrees)
        :param findSelfIntersectingSupport: Generates supports that intersect with the part

        :return: A list of BlockSupports
        """
        supportBlocks = super().identifySupportRegions(part, overhangAngle, findSelfIntersectingSupport)

        gridBlocks = []

        for block in supportBlocks:
            gridBlock = GridBlockSupport(block.supportObject,
                                         block.supportVolume, block.supportSurface, block.intersectsPart)

            # Assign the GridBlock Parameters
            gridBlock.gridSpacing = self._gridSpacing
            gridBlock.numSkinMeshSubdivideIterations = self._numSkinMeshSubdivideIterations

            # Support Teeth Parameters
            gridBlock.supportTeethHeight = self._supportTeethHeight
            gridBlock.supportTeethTopLength = self._supportTeethHeight
            gridBlock.supportTeethBottomLength     = self._supportTeethBottomLength
            gridBlock.supportTeethBaseInterval     = self._supportTeethBaseInterval
            gridBlock.supportTeethUpperPenetration = self._supportTeethUpperPenetration
            gridBlock.supportWallThickness = self._supportWallThickness

            # Options for generating the truss
            gridBlock.useSupportSkin        = self._useSupportSkin
            gridBlock.useSupportBorder      = self._useSupportBorder

            gridBlock.useLowerSupportTeeth  = self._useLowerSupportTeeth
            gridBlock.useUpperSupportTeeth  = self._useUpperSupportTeeth

            gridBlock.supportBorderDistance = self._supportBorderDistance
            gridBlock.trussWidth = self._trussWidth
            gridBlock.trussAngle = self._trussAngle
            gridBlock.mergeMesh  = self._mergeMesh
            gridBlock._upperSurface = block._upperSurface

            gridBlocks.append(gridBlock)

        return gridBlocks
