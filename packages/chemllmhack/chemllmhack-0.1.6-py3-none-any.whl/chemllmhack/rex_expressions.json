{
  "help_info": "Rex is the official language for RUSH platform\n\nMath\nYou can write mathematical expressions intuitively, and they will follow the usual operator precedence:\nw + x * y + z\n\n\nFunction Calls\nYou can call functions by naming them and listing their arguments (white-space separated). For example, assuming a function called auto3D:\nauto3D x y z\n\nTo pass the result of one function into another, use parentheses to ensure the correct order:\nexess a b (auto3D x y z)\nThis passes three arguments to the exess function, with the third being the result of auto3D x y z.\n\nCommon Mistake\nAvoid dropping the parentheses:\nexess a b auto3D x y z\nThis tries to call exess with six arguments, the third being the auto3D function itself, not its result. This causes type errors.\n\nCalling Operators Like Functions\nYou can use math operators in a function-like manner by surrounding them with parentheses:\n(+) x y\n\nCurrying (Partially Calling a Function)\nIn Rex, if a function takes N arguments, you do not have to provide all N arguments at once. It is acceptable to pass fewer:\n(*) 2\nThis returns a new function that waits for more arguments. This is how all functions are called in Rex. Whitespace is left associative, meaning f x y z is equivalent to (((f x) y) z).\n\nMapping\nTo apply a function to a list of values, use the map function:\nmap ((*) 2) [1, 2, 3]\nThis doubles each item in the list, resulting in [2, 4, 6].\n\nFirst Supercomputing Module\nauto3D r1 o1 (map smi list_of_smols)\nThis extracts the SMILES string from each Smol entity in list_of_smols and calls auto3D with those SMILES as inputs. The result is a list of auto3D outputs for each Smol entity.\n\nProtein Preparation\nmap (colabfold r3 o3 . mmseqs2 r2 o2 . seq) list_of_proteins\nThis extracts the FASTA sequence from each protein, runs a multiple sequence alignment, and uses it for colabfold. The output is a list of predicted structures for each input protein.\n\nPocket Prediction\np2rank r4 o4 list_of_conformers\nThis pattern continues, showing a similar usage for pocket prediction.\n\nPutting It Together\nCombine these functions:\ngnina r5 o5 \n  (map (colabfold r3 o3 . mmseqs2 r2 o2 . seq) list_of_proteins)\n  (p2rank r4 o4 (map (colabfold r3 o3 . mmseqs2 r2 o2 . seq) list_of_proteins))\n  (flatten (auto3D r1 o1 (map smi list_of_smols)))\n\nThis calls gnina for every small molecule against every binding site for every protein. However, this is inefficient as it runs mmseqs2 and colabfold twice. Improve efficiency using a lambda:\n(\\ps ->\n  gnina r5 o5 \n    ps\n    (p2rank r4 o4 ps)\n    (flatten (auto3D r1 o1 (map smi list_of_smols))))\n  (map (colabfold r3 o3 . mmseqs2 r2 o2 . seq) list_of_proteins)\n\nThis runs the sequence alignment and folding functions once, assigns it to ps, and re-uses ps.\n\n(Note: Rex is capable of not recomputing identical expressions, but using a lambda is good practice to simplify changes.)",
  "prepare_protein": "prepared_protein = (get \"Ok\" (get 0 (await (get 1 \n    ( prepare_protein_rex\n      (json '{\"resources\":{\"cpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet\"}')\n      (arg (json '{}'))\n      (arg [[ (upload (json protein_sequence)) ]])\n    )\n  ))))",
  "auto3d": "(get \"Ok\" (get 0 (await (get 1 \n    ( auto3d_rex\n      (json '{\"resources\":{\"gpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet2\"}')\n      (arg (json '{\"k\":1}'))\n      (arg smiles)\n    )\n  ))))",
  "gnina": "gnina_rex_template",
  "gmx": "Still in progress, please check other module first.",
  "comprehensive_example": "let\n  smiles = [\"CCCC\", \"CCCN\", \"CCCO\"],  // Example SMILES inputs\n  protein_sequence = \"MKVLLAAVILGVVIGAIVFGIPGK\",  // Example protein sequence\n  \n  // Run auto3d to generate 3D conformers\n  auto3d_result = (get \"Ok\" (get 0 (await (get 1 \n    ( auto3d_rex\n      (json '{\"resources\":{\"gpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet2\"}')\n      (arg (json '{\"k\":1}'))\n      (arg smiles)\n    )\n  )))),\n  \n  // Prepare the protein\n  prepared_protein = (get \"Ok\" (get 0 (await (get 1 \n    ( prepare_protein_rex\n      (json '{\"resources\":{\"cpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet\"}')\n      (arg (json '{}'))\n      (arg [[ (upload (json protein_sequence)) ]])\n    )\n  )))),\n  \n  // Run p2rank to predict binding sites\n  p2rank_result = (get \"Ok\" (get 0 (await (get 1 \n    ( p2rank_rex\n      (json '{\"resources\":{\"cpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet\"}')\n      (arg (json '{\"use_alphafold_config\":false}'))\n      (arg prepared_protein)\n    )\n  )))),\n  \n  // Run gnina for docking\n  gnina_result = (get \"Ok\" (get 0 (await (get 1 \n    ( gnina_rex\n      (json '{\"resources\":{\"gpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet2\"}')\n      (arg (json '{\"num_modes\":10,\"exhaustiveness\":8}'))\n      (arg prepared_protein)\n      (arg [(get 0 (get 0 p2rank_result))])  // Use the first predicted binding site\n      (arg auto3d_result)\n      (arg [])  // No ligand library partitions for this composition\n    )\n  ))))\n\nin\n  {\n    auto3d_conformers: auto3d_result,\n    prepared_protein: prepared_protein,\n    binding_sites: p2rank_result,\n    docking_results: gnina_result\n  }",
  "hackthon_task": "Task One: Correlation Coefficient Calculation\n\nFrom the dataset we provide, select specific BTK proteins and their corresponding ligands in SMILES format.\nRun the in-silico protocol on the RUSH platform to obtain and record the final simulated affinity values or other potential reference values.\nUse the provided benchmark function to calculate the correlation coefficient between the simulated affinity values and the experimental affinity values in the dataset to assess the accuracy of the simulation.\nTask Two: RMSD Calculation\n\nWe will provide a set of protein structures (without ligands) and a series of ligands in SMILES format.\nParticipants need to predict the protein-ligand complex structures, run the in-silico protocol on the RUSH platform, and generate simulated PDB files.\nUse the benchmark function; our provided benchmark function will automatically align the generated protein structures and calculate the RMSD values compared to the actual crystal structures to assess the consistency of the structure prediction.",
  "gnina_parameter": "protein_conformer: Object[Conformer];\noriginal_ligand_conformer: Object[Conformer];\nligands_conformers: Object[[Conformer]];\ngnina_options: GninaOptions {\n    minimise: bool?,\n    num_modes: u32?,\n    autobox: f32?,\n    exhaustiveness: u32?,\n    docking_site: GninaDockingSite {\n        center_x: f32,\n        size_y: f32,\n        size_x: f32,\n        center_y: f32,\n        center_z: f32,\n        size_z: f32\n    }?\n}?\n->\nresults: Object {\n    path: @[[GninaResult {\n        score: GninaScore {\n            cnn_score: f32,\n            affinity: f32,\n            cnn_affinity: f32,\n            mode: i32\n        },\n        ligand: Conformer {\n            amino_acid_seq_ids: [i32]?,\n            amino_acid_labels: [Label {u32, string}]?,\n            residue_insertion_codes: [string]?,\n            amino_acid_insertion_codes: [string]?,\n            residue_labels: [Label {u32, string}]?,\n            amino_acids: [[u32]]?,\n            residue_seq: [string]?,\n            binding_site_interactions: [BindingSiteInteraction {\n                ligand_atom_idx: u32?,\n                receptor_atom_idx: u32?,\n                ligand_xyz: [f32]?,\n                ligand_residue_idx: u32,\n                receptor_amino_acid_idx: u32,\n                receptor_is_positively_charged: bool,\n                receptor_is_donor: bool,\n                receptor_xyz: [f32]?,\n                pi_stack_kind: PiStackKind[P | T]?,\n                receptor_is_charged: bool\n            }]?,\n            residues: [[u32]]?,\n            subunits: [[u32]]?,\n            topology: Topology {\n                connectivity: [Bond {u32, u32, u8}]?,\n                formal_charges: [i8]?,\n                fragments: [[u32]]?,\n                fragment_multiplicities: [i8]?,\n                atom_charges: [i8]?,\n                fragment_charges: [i8]?,\n                velocities: [f32]?,\n                alts: [Alt {u32, [u32]}]?,\n                atom_labels: [string]?,\n                fragment_partial_charges: [f32]?,\n                geometry: [f32],\n                fragment_formal_charges: [i8]?,\n                partial_charges: [f32]?,\n                labels: [string]?,\n                version: TopologyVersion[V0 | V1]?\n            },\n            residue_seq_ids: [i32]?\n        }\n    }]],\n    size: u32,\n    format: ObjectFormat[json | bin]?\n}\n\nParameters\n\nprotein_conformer: protein conformer\noriginal_ligand_conformer: optional reference ligand for binding site\nligands_conformers: ligand conformers\ngnina_options: Within the GninaOptions;\nThe exhaustiveness would determine the search extent for the docking algorithm.\nThe num_modes would determine the number of dock poses to report.\nThe minimise argument would determine whether to minimise the energy of the final pose.\nThe docking_site would be for specifying where to dock the ligand to.\nReturns\n\na list of ligand conformers and their scores",
  "auto3d_parameter": "molecule_file: Object[@$Bytes];\nmolecule_file_type: string;\noptions: Auto3dOptions {\n    window: f32?,\n    memory: u32?,\n    capacity: u32?,\n    patience: u32?,\n    opt_steps: u32?,\n    convergence_threshold: f32?,\n    k: i32?,\n    mpi_np: u32?,\n    threshold: f32?,\n    use_gpu: bool?,\n    enumerate_tautomer: bool?,\n    job_name: string?,\n    enumerate_isomer: bool?,\n    verbose: bool?,\n    max_confs: u32?,\n    optimizing_engine: Auto3dOptimizingEngines[ANI2x | ANI2xt | AIMNET]?,\n    gpu_idx: [u32]?\n}\n->\nconformer_sdf: Object[@$SDF];\nconformers: Object[[Conformer]]\n\nParameters\n\nmolecule_file: The input molecules as a file; either one SMILES string per line, or an SDF\nmolecule_file_type: The string 'smi' or 'sdf', depending on the input type\noptions: A dict with options to pass; see auto3d docs for details\nReturns\n\nA sdf file containing the ligand(s)'s conformers\n\nReturns\n\nA vec of qdxf conformers"
}