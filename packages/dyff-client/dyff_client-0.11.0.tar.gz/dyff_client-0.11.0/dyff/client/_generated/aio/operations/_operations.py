# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.2, generator: @autorest/python@6.13.19)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from io import IOBase
from typing import (
    IO,
    Any,
    Callable,
    Dict,
    List,
    Optional,
    Type,
    TypeVar,
    Union,
    cast,
    overload,
)

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ...operations._operations import (
    build_datasets_create_request,
    build_datasets_delete_request,
    build_datasets_documentation_request,
    build_datasets_downlinks_request,
    build_datasets_edit_documentation_request,
    build_datasets_finalize_request,
    build_datasets_get_request,
    build_datasets_label_request,
    build_datasets_query_request,
    build_datasets_upload_request,
    build_evaluations_create_request,
    build_evaluations_delete_request,
    build_evaluations_downlinks_request,
    build_evaluations_get_request,
    build_evaluations_label_request,
    build_evaluations_query_request,
    build_inferenceservices_create_request,
    build_inferenceservices_delete_request,
    build_inferenceservices_documentation_request,
    build_inferenceservices_edit_documentation_request,
    build_inferenceservices_get_request,
    build_inferenceservices_label_request,
    build_inferenceservices_query_request,
    build_inferencesessions_create_request,
    build_inferencesessions_delete_request,
    build_inferencesessions_get_request,
    build_inferencesessions_infer_request,
    build_inferencesessions_label_request,
    build_inferencesessions_query_request,
    build_inferencesessions_ready_request,
    build_inferencesessions_terminate_request,
    build_inferencesessions_token_request,
    build_measurements_create_request,
    build_measurements_delete_request,
    build_measurements_downlinks_request,
    build_measurements_get_request,
    build_measurements_label_request,
    build_measurements_logs_request,
    build_measurements_query_request,
    build_methods_create_request,
    build_methods_delete_request,
    build_methods_documentation_request,
    build_methods_edit_documentation_request,
    build_methods_get_request,
    build_methods_label_request,
    build_methods_query_request,
    build_models_create_request,
    build_models_delete_request,
    build_models_documentation_request,
    build_models_edit_documentation_request,
    build_models_get_request,
    build_models_label_request,
    build_models_query_request,
    build_modules_create_request,
    build_modules_delete_request,
    build_modules_documentation_request,
    build_modules_downlinks_request,
    build_modules_edit_documentation_request,
    build_modules_finalize_request,
    build_modules_get_request,
    build_modules_label_request,
    build_modules_query_request,
    build_modules_upload_request,
    build_reports_create_request,
    build_reports_delete_request,
    build_reports_downlinks_request,
    build_reports_get_request,
    build_reports_label_request,
    build_reports_logs_request,
    build_reports_query_request,
    build_safetycases_create_request,
    build_safetycases_delete_request,
    build_safetycases_downlinks_request,
    build_safetycases_get_request,
    build_safetycases_label_request,
    build_safetycases_logs_request,
    build_safetycases_query_request,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import (
        MutableMapping,  # type: ignore  # pylint: disable=ungrouped-imports
    )
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[
    Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]
]


class DatasetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.aio.DyffV0API`'s
        :attr:`datasets` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    async def label(
        self,
        dataset_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Dataset.

        Update labels for an existing Dataset.

        :param dataset_id: Required.
        :type dataset_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def label(
        self,
        dataset_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        """Update labels for an existing Dataset.

        Update labels for an existing Dataset.

        :param dataset_id: Required.
        :type dataset_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def label(
        self, dataset_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Dataset.

        Update labels for an existing Dataset.

        :param dataset_id: Required.
        :type dataset_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_datasets_label_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        name: Optional[str] = None,
        **kwargs: Any,
    ) -> Union[List[JSON], JSON]:
        # pylint: disable=line-too-long
        """Get all Datasets matching a query.

        Get all Datasets matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword name: Default value is None.
        :paramtype name: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",  # Account that owns the entity. Required.
                        "artifacts": [
                            {
                                "path": "str",  # The relative path of the artifact
                                  within the tree. Required.
                                "digest": {
                                    "md5": "str"  # Optional. md5 digest of
                                      artifact data.
                                },
                                "kind": "str"  # Optional. The kind of artifact.
                            }
                        ],
                        "id": "str",  # Unique identifier of the entity. Required.
                        "name": "str",  # The name of the Dataset. Required.
                        "schema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "annotations": [
                            {
                                "key": "str",  # The annotation key. A DNS label with
                                  an optional DNS domain prefix. For example: 'my-key',
                                  'your.com/key_0'. Names prefixed with 'dyff.io/',
                                  'subdomain.dyff.io/', etc. are reserved.  See
                                  https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                                  for detailed naming rules. Required.
                                "value": "str"  # The annotation value. An arbitrary
                                  string. Required.
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation
                          time (assigned by system).
                        "kind": "Dataset",  # Optional. Default value is "Dataset". Kind.
                          "Dataset"
                        "labels": {
                            "str": "str"  # Optional. A set of key-value labels for the
                              resource. Used to specify identifying attributes of resources that are
                              meaningful to users but do not imply semantics in the dyff system.  The
                              keys are DNS labels with an optional DNS domain prefix. For example:
                              'my-key', 'your.com/key_0'. Keys prefixed with 'dyff.io/',
                              'subdomain.dyff.io/', etc. are reserved.  The label values are
                              alphanumeric characters separated by '.', '-', or '_'.  We follow the
                              kubernetes label conventions closely. See:
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                        },
                        "reason": "str",  # Optional. Reason for current status (assigned by
                          system).
                        "schemaVersion": "0.1",  # Optional. Default value is "0.1". The
                          schema version. "0.1"
                        "status": "str",  # Optional. Top-level resource status (assigned by
                          system).
                        "views": [
                            {
                                "id": "str",  # Unique ID of the DataView. Required.
                                "schema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "viewOf": "str",  # ID of the resource that this is a
                                  view of. Required.
                                "adapterPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ]
                            }
                        ]
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_datasets_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            name=name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a Dataset.

        Create a Dataset.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifacts": [
                        {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        }
                    ],
                    "name": "str",  # The name of the Dataset. Required.
                    "schema": {
                        "arrowSchema": "str",  # The schema in Arrow format, encoded with
                          dyff.schema.arrow.encode_schema(). This is required, but can be populated
                          from a DyffDataSchema. Required.
                        "dyffSchema": {
                            "components": [
                                "str"  # A list of named dyff data schemas. The final
                                  schema is the composition of these component schemas. Required.
                            ],
                            "schemaVersion": "0.1"  # Optional. Default value is "0.1".
                              The dyff schema version. "0.1"
                        },
                        "jsonSchema": {}  # Optional. The schema in JSON Schema format.
                    },
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "views": [
                        {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifacts": [
                        {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        }
                    ],
                    "id": "str",  # Unique identifier of the entity. Required.
                    "name": "str",  # The name of the Dataset. Required.
                    "schema": {
                        "arrowSchema": "str",  # The schema in Arrow format, encoded with
                          dyff.schema.arrow.encode_schema(). This is required, but can be populated
                          from a DyffDataSchema. Required.
                        "dyffSchema": {
                            "components": [
                                "str"  # A list of named dyff data schemas. The final
                                  schema is the composition of these component schemas. Required.
                            ],
                            "schemaVersion": "0.1"  # Optional. Default value is "0.1".
                              The dyff schema version. "0.1"
                        },
                        "jsonSchema": {}  # Optional. The schema in JSON Schema format.
                    },
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "Dataset",  # Optional. Default value is "Dataset". Kind. "Dataset"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str",  # Optional. Top-level resource status (assigned by system).
                    "views": [
                        {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        }
                    ]
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a Dataset.

        Create a Dataset.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifacts": [
                        {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        }
                    ],
                    "id": "str",  # Unique identifier of the entity. Required.
                    "name": "str",  # The name of the Dataset. Required.
                    "schema": {
                        "arrowSchema": "str",  # The schema in Arrow format, encoded with
                          dyff.schema.arrow.encode_schema(). This is required, but can be populated
                          from a DyffDataSchema. Required.
                        "dyffSchema": {
                            "components": [
                                "str"  # A list of named dyff data schemas. The final
                                  schema is the composition of these component schemas. Required.
                            ],
                            "schemaVersion": "0.1"  # Optional. Default value is "0.1".
                              The dyff schema version. "0.1"
                        },
                        "jsonSchema": {}  # Optional. The schema in JSON Schema format.
                    },
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "Dataset",  # Optional. Default value is "Dataset". Kind. "Dataset"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str",  # Optional. Top-level resource status (assigned by system).
                    "views": [
                        {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        }
                    ]
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create a Dataset.

        Create a Dataset.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifacts": [
                        {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        }
                    ],
                    "name": "str",  # The name of the Dataset. Required.
                    "schema": {
                        "arrowSchema": "str",  # The schema in Arrow format, encoded with
                          dyff.schema.arrow.encode_schema(). This is required, but can be populated
                          from a DyffDataSchema. Required.
                        "dyffSchema": {
                            "components": [
                                "str"  # A list of named dyff data schemas. The final
                                  schema is the composition of these component schemas. Required.
                            ],
                            "schemaVersion": "0.1"  # Optional. Default value is "0.1".
                              The dyff schema version. "0.1"
                        },
                        "jsonSchema": {}  # Optional. The schema in JSON Schema format.
                    },
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "views": [
                        {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifacts": [
                        {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        }
                    ],
                    "id": "str",  # Unique identifier of the entity. Required.
                    "name": "str",  # The name of the Dataset. Required.
                    "schema": {
                        "arrowSchema": "str",  # The schema in Arrow format, encoded with
                          dyff.schema.arrow.encode_schema(). This is required, but can be populated
                          from a DyffDataSchema. Required.
                        "dyffSchema": {
                            "components": [
                                "str"  # A list of named dyff data schemas. The final
                                  schema is the composition of these component schemas. Required.
                            ],
                            "schemaVersion": "0.1"  # Optional. Default value is "0.1".
                              The dyff schema version. "0.1"
                        },
                        "jsonSchema": {}  # Optional. The schema in JSON Schema format.
                    },
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "Dataset",  # Optional. Default value is "Dataset". Kind. "Dataset"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str",  # Optional. Top-level resource status (assigned by system).
                    "views": [
                        {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        }
                    ]
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_datasets_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get(self, dataset_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get a Dataset by its key.

        Get a Dataset by its key.

        Raises a 404 error if no entity exists with that key.

        :param dataset_id: Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifacts": [
                        {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        }
                    ],
                    "id": "str",  # Unique identifier of the entity. Required.
                    "name": "str",  # The name of the Dataset. Required.
                    "schema": {
                        "arrowSchema": "str",  # The schema in Arrow format, encoded with
                          dyff.schema.arrow.encode_schema(). This is required, but can be populated
                          from a DyffDataSchema. Required.
                        "dyffSchema": {
                            "components": [
                                "str"  # A list of named dyff data schemas. The final
                                  schema is the composition of these component schemas. Required.
                            ],
                            "schemaVersion": "0.1"  # Optional. Default value is "0.1".
                              The dyff schema version. "0.1"
                        },
                        "jsonSchema": {}  # Optional. The schema in JSON Schema format.
                    },
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "Dataset",  # Optional. Default value is "Dataset". Kind. "Dataset"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str",  # Optional. Top-level resource status (assigned by system).
                    "views": [
                        {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        }
                    ]
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Mark a Dataset for deletion.

        Mark a Dataset for deletion.

        :param dataset_id: Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_delete_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def upload(self, dataset_id: str, artifact_path: str, **kwargs: Any) -> JSON:
        """Get a signed URL to which the given artifact can be uploaded.

        Get a signed URL to which the given artifact can be uploaded.

        :param dataset_id: Required.
        :type dataset_id: str
        :param artifact_path: Required.
        :type artifact_path: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "method": "str",  # The HTTP method applicable to the URL. Required.
                    "url": "str",  # The signed URL. Required.
                    "headers": {
                        "str": "str"  # Optional. Mandatory headers that must be passed with
                          the request.
                    }
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_upload_request(
            dataset_id=dataset_id,
            artifact_path=artifact_path,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def finalize(self, dataset_id: str, **kwargs: Any) -> Union[Any, JSON]:
        """Indicate that all dataset artifacts have been uploaded.

        Indicate that all dataset artifacts have been uploaded.

        :param dataset_id: Required.
        :type dataset_id: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        _request = build_datasets_finalize_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def downlinks(
        self, dataset_id: str, **kwargs: Any
    ) -> Union[List[JSON], JSON]:
        """Get a list of signed GET URLs from which Dataset artifacts can be downloaded.

        Get a list of signed GET URLs from which Dataset artifacts can be downloaded.

        :param dataset_id: Required.
        :type dataset_id: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "artifact": {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        },
                        "signedURL": {
                            "method": "str",  # The HTTP method applicable to the URL.
                              Required.
                            "url": "str",  # The signed URL. Required.
                            "headers": {
                                "str": "str"  # Optional. Mandatory headers that must
                                  be passed with the request.
                            }
                        }
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_datasets_downlinks_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def documentation(self, dataset_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get the documentation associated with a Dataset.

        Get the documentation associated with a Dataset.

        Raises a 404 error if no entity exists with that key.

        :param dataset_id: Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_documentation_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def edit_documentation(
        self,
        dataset_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with a Dataset.

        Edit the documentation associated with a Dataset.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param dataset_id: Required.
        :type dataset_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def edit_documentation(
        self,
        dataset_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with a Dataset.

        Edit the documentation associated with a Dataset.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param dataset_id: Required.
        :type dataset_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def edit_documentation(
        self, dataset_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with a Dataset.

        Edit the documentation associated with a Dataset.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param dataset_id: Required.
        :type dataset_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_datasets_edit_documentation_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class EvaluationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.aio.DyffV0API`'s
        :attr:`evaluations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    async def label(
        self,
        evaluation_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Evaluation.

        Update labels for an existing Evaluation.

        :param evaluation_id: Required.
        :type evaluation_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def label(
        self,
        evaluation_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        """Update labels for an existing Evaluation.

        Update labels for an existing Evaluation.

        :param evaluation_id: Required.
        :type evaluation_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def label(
        self, evaluation_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Evaluation.

        Update labels for an existing Evaluation.

        :param evaluation_id: Required.
        :type evaluation_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_evaluations_label_request(
            evaluation_id=evaluation_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        dataset: Optional[str] = None,
        inference_service: Optional[str] = None,
        inference_service_name: Optional[str] = None,
        model: Optional[str] = None,
        model_name: Optional[str] = None,
        **kwargs: Any,
    ) -> Union[List[JSON], JSON]:
        # pylint: disable=line-too-long
        """Get all Evaluations matching a query.

        Get all Evaluations matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword dataset: Default value is None.
        :paramtype dataset: str
        :keyword inference_service: Default value is None.
        :paramtype inference_service: str
        :keyword inference_service_name: Default value is None.
        :paramtype inference_service_name: str
        :keyword model: Default value is None.
        :paramtype model: str
        :keyword model_name: Default value is None.
        :paramtype model_name: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",  # Account that owns the entity. Required.
                        "dataset": "str",  # The Dataset to evaluate on. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "inferenceSession": {
                            "inferenceService": {
                                "account": "str",  # Account that owns the entity.
                                  Required.
                                "id": "str",  # Unique identifier of the entity.
                                  Required.
                                "interface": {
                                    "endpoint": "str",  # HTTP endpoint for
                                      inference. Required.
                                    "outputSchema": {
                                        "arrowSchema": "str",  # The schema
                                          in Arrow format, encoded with
                                          dyff.schema.arrow.encode_schema(). This is required, but can
                                          be populated from a DyffDataSchema. Required.
                                        "dyffSchema": {
                                            "components": [
                                                "str"  # A list of
                                                  named dyff data schemas. The final schema is the
                                                  composition of these component schemas. Required.
                                            ],
                                            "schemaVersion": "0.1"  #
                                              Optional. Default value is "0.1". The dyff schema
                                              version. "0.1"
                                        },
                                        "jsonSchema": {}  # Optional. The
                                          schema in JSON Schema format.
                                    },
                                    "inputPipeline": [
                                        {
                                            "kind": "str",  # Name of a
                                              schema adapter available on the platform. Required.
                                            "configuration": {}  #
                                              Optional. Configuration for the schema adapter. Must be
                                              encodable as JSON.
                                        }
                                    ],
                                    "outputPipeline": [
                                        {
                                            "kind": "str",  # Name of a
                                              schema adapter available on the platform. Required.
                                            "configuration": {}  #
                                              Optional. Configuration for the schema adapter. Must be
                                              encodable as JSON.
                                        }
                                    ]
                                },
                                "name": "str",  # The name of the service. Required.
                                "builder": {
                                    "kind": "str",  # Kind. Required.
                                    "args": [
                                        "str"  # Optional. Args.
                                    ]
                                },
                                "model": {
                                    "account": "str",  # Account that owns the
                                      entity. Required.
                                    "artifact": {
                                        "kind": "str",  # How the model data
                                          is represented. Required. "HuggingFaceCache"
                                        "huggingFaceCache": {
                                            "repoID": "str",  # Name of
                                              the model in the HuggingFace cache. Required.
                                            "revision": "str"  # Model
                                              revision. Required.
                                        }
                                    },
                                    "id": "str",  # Unique identifier of the
                                      entity. Required.
                                    "name": "str",  # The name of the Model.
                                      Required.
                                    "storage": {
                                        "medium": "str"  # Storage medium.
                                          Required. Known values are: "ObjectStorage" and
                                          "PersistentVolume".
                                    }
                                },
                                "outputViews": [
                                    {
                                        "id": "str",  # Unique ID of the
                                          DataView. Required.
                                        "schema": {
                                            "arrowSchema": "str",  # The
                                              schema in Arrow format, encoded with
                                              dyff.schema.arrow.encode_schema(). This is required, but
                                              can be populated from a DyffDataSchema. Required.
                                            "dyffSchema": {
                                                "components": [
                                                    "str"  # A
                                                      list of named dyff data schemas. The final schema
                                                      is the composition of these component schemas.
                                                      Required.
                                                ],
                                                "schemaVersion":
                                                  "0.1"  # Optional. Default value is "0.1". The dyff
                                                  schema version. "0.1"
                                            },
                                            "jsonSchema": {}  # Optional.
                                              The schema in JSON Schema format.
                                        },
                                        "viewOf": "str",  # ID of the
                                          resource that this is a view of. Required.
                                        "adapterPipeline": [
                                            {
                                                "kind": "str",  #
                                                  Name of a schema adapter available on the platform.
                                                  Required.
                                                "configuration": {}
                                                  # Optional. Configuration for the schema adapter.
                                                  Must be encodable as JSON.
                                            }
                                        ]
                                    }
                                ],
                                "runner": {
                                    "kind": "str",  # An enumeration. Required.
                                      Known values are: "bentoml_service_openllm", "huggingface",
                                      "mock", "standalone", and "vllm".
                                    "resources": {
                                        "storage": "str",  # Amount of
                                          storage required for packaged model, in k8s Quantity
                                          notation. Required.
                                        "memory": "str"  # Optional. Amount
                                          of memory required to run the model on CPU, in k8s Quantity
                                          notation.
                                    },
                                    "accelerator": {
                                        "kind": "str",  # The kind of
                                          accelerator; available kinds are {{GPU}}. Required.
                                        "gpu": {
                                            "hardwareTypes": [
                                                "str"  # Acceptable
                                                  GPU hardware types. Required.
                                            ],
                                            "count": 1,  # Optional.
                                              Default value is 1. Number of GPUs required.
                                            "memory": "str"  # Optional.
                                              [DEPRECATED] Amount of GPU memory required, in k8s
                                              Quantity notation.
                                        }
                                    },
                                    "args": [
                                        "str"  # Optional. Command line
                                          arguments to forward to the runner.
                                    ],
                                    "image": {
                                        "digest": "str",  # The digest of the
                                          image. The image is always pulled by digest, even if 'tag' is
                                          specified. Required.
                                        "host": "str",  # The host of the
                                          container image registry. Required.
                                        "name": "str",  # The name of the
                                          image. Required.
                                        "tag": "str"  # Optional. The tag of
                                          the image. Although the image is always pulled by digest,
                                          including the tag is strongly recommended as it is often the
                                          main source of versioning information.
                                    }
                                }
                            },
                            "accelerator": {
                                "kind": "str",  # The kind of accelerator; available
                                  kinds are {{GPU}}. Required.
                                "gpu": {
                                    "hardwareTypes": [
                                        "str"  # Acceptable GPU hardware
                                          types. Required.
                                    ],
                                    "count": 1,  # Optional. Default value is 1.
                                      Number of GPUs required.
                                    "memory": "str"  # Optional. [DEPRECATED]
                                      Amount of GPU memory required, in k8s Quantity notation.
                                }
                            },
                            "expires": "2020-02-20 00:00:00",  # Optional. Expiration
                              time for the session. Use of this field is recommended to avoid
                              accidental compute costs.
                            "replicas": 1,  # Optional. Default value is 1. Number of
                              model replicas.
                            "useSpotPods": True  # Optional. Default value is True. Use
                              'spot pods' for cheaper computation.
                        },
                        "annotations": [
                            {
                                "key": "str",  # The annotation key. A DNS label with
                                  an optional DNS domain prefix. For example: 'my-key',
                                  'your.com/key_0'. Names prefixed with 'dyff.io/',
                                  'subdomain.dyff.io/', etc. are reserved.  See
                                  https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                                  for detailed naming rules. Required.
                                "value": "str"  # The annotation value. An arbitrary
                                  string. Required.
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation
                          time (assigned by system).
                        "inferenceSessionReference": "str",  # Optional. ID of a running
                          inference session that will be used for the evaluation instead of starting a
                          new one.
                        "kind": "Evaluation",  # Optional. Default value is "Evaluation".
                          Kind. "Evaluation"
                        "labels": {
                            "str": "str"  # Optional. A set of key-value labels for the
                              resource. Used to specify identifying attributes of resources that are
                              meaningful to users but do not imply semantics in the dyff system.  The
                              keys are DNS labels with an optional DNS domain prefix. For example:
                              'my-key', 'your.com/key_0'. Keys prefixed with 'dyff.io/',
                              'subdomain.dyff.io/', etc. are reserved.  The label values are
                              alphanumeric characters separated by '.', '-', or '_'.  We follow the
                              kubernetes label conventions closely. See:
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                        },
                        "reason": "str",  # Optional. Reason for current status (assigned by
                          system).
                        "replications": 1,  # Optional. Default value is 1. Number of
                          replications to run.
                        "schemaVersion": "0.1",  # Optional. Default value is "0.1". The
                          schema version. "0.1"
                        "status": "str",  # Optional. Top-level resource status (assigned by
                          system).
                        "workersPerReplica": 0  # Optional. Number of data workers per
                          inference service replica.
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_evaluations_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            dataset=dataset,
            inference_service=inference_service,
            inference_service_name=inference_service_name,
            model=model,
            model_name=model_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create an Evaluation.

        Create an Evaluation.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "dataset": "str",  # The Dataset to evaluate on. Required.
                    "inferenceSession": {
                        "inferenceService": "str",  # InferenceService ID. Required.
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "expires": "2020-02-20 00:00:00",  # Optional. Expiration time for
                          the session. Use of this field is recommended to avoid accidental compute
                          costs.
                        "replicas": 1,  # Optional. Default value is 1. Number of model
                          replicas.
                        "useSpotPods": True  # Optional. Default value is True. Use 'spot
                          pods' for cheaper computation.
                    },
                    "inferenceSessionReference": "str",  # Optional. The ID of a running
                      inference session that will be used for the evaluation, instead of starting a new
                      one.
                    "replications": 1,  # Optional. Default value is 1. Number of replications to
                      run.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "workersPerReplica": 0  # Optional. Number of data workers per inference
                      service replica.
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "dataset": "str",  # The Dataset to evaluate on. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "inferenceSession": {
                        "inferenceService": {
                            "account": "str",  # Account that owns the entity. Required.
                            "id": "str",  # Unique identifier of the entity. Required.
                            "interface": {
                                "endpoint": "str",  # HTTP endpoint for inference.
                                  Required.
                                "outputSchema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ]
                            },
                            "name": "str",  # The name of the service. Required.
                            "builder": {
                                "kind": "str",  # Kind. Required.
                                "args": [
                                    "str"  # Optional. Args.
                                ]
                            },
                            "model": {
                                "account": "str",  # Account that owns the entity.
                                  Required.
                                "artifact": {
                                    "kind": "str",  # How the model data is
                                      represented. Required. "HuggingFaceCache"
                                    "huggingFaceCache": {
                                        "repoID": "str",  # Name of the model
                                          in the HuggingFace cache. Required.
                                        "revision": "str"  # Model revision.
                                          Required.
                                    }
                                },
                                "id": "str",  # Unique identifier of the entity.
                                  Required.
                                "name": "str",  # The name of the Model. Required.
                                "storage": {
                                    "medium": "str"  # Storage medium. Required.
                                      Known values are: "ObjectStorage" and "PersistentVolume".
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",  # Unique ID of the DataView.
                                      Required.
                                    "schema": {
                                        "arrowSchema": "str",  # The schema
                                          in Arrow format, encoded with
                                          dyff.schema.arrow.encode_schema(). This is required, but can
                                          be populated from a DyffDataSchema. Required.
                                        "dyffSchema": {
                                            "components": [
                                                "str"  # A list of
                                                  named dyff data schemas. The final schema is the
                                                  composition of these component schemas. Required.
                                            ],
                                            "schemaVersion": "0.1"  #
                                              Optional. Default value is "0.1". The dyff schema
                                              version. "0.1"
                                        },
                                        "jsonSchema": {}  # Optional. The
                                          schema in JSON Schema format.
                                    },
                                    "viewOf": "str",  # ID of the resource that
                                      this is a view of. Required.
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",  # Name of a
                                              schema adapter available on the platform. Required.
                                            "configuration": {}  #
                                              Optional. Configuration for the schema adapter. Must be
                                              encodable as JSON.
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",  # An enumeration. Required. Known
                                  values are: "bentoml_service_openllm", "huggingface", "mock",
                                  "standalone", and "vllm".
                                "resources": {
                                    "storage": "str",  # Amount of storage
                                      required for packaged model, in k8s Quantity notation. Required.
                                    "memory": "str"  # Optional. Amount of memory
                                      required to run the model on CPU, in k8s Quantity notation.
                                },
                                "accelerator": {
                                    "kind": "str",  # The kind of accelerator;
                                      available kinds are {{GPU}}. Required.
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"  # Acceptable GPU
                                              hardware types. Required.
                                        ],
                                        "count": 1,  # Optional. Default
                                          value is 1. Number of GPUs required.
                                        "memory": "str"  # Optional.
                                          [DEPRECATED] Amount of GPU memory required, in k8s Quantity
                                          notation.
                                    }
                                },
                                "args": [
                                    "str"  # Optional. Command line arguments to
                                      forward to the runner.
                                ],
                                "image": {
                                    "digest": "str",  # The digest of the image.
                                      The image is always pulled by digest, even if 'tag' is specified.
                                      Required.
                                    "host": "str",  # The host of the container
                                      image registry. Required.
                                    "name": "str",  # The name of the image.
                                      Required.
                                    "tag": "str"  # Optional. The tag of the
                                      image. Although the image is always pulled by digest, including
                                      the tag is strongly recommended as it is often the main source of
                                      versioning information.
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "expires": "2020-02-20 00:00:00",  # Optional. Expiration time for
                          the session. Use of this field is recommended to avoid accidental compute
                          costs.
                        "replicas": 1,  # Optional. Default value is 1. Number of model
                          replicas.
                        "useSpotPods": True  # Optional. Default value is True. Use 'spot
                          pods' for cheaper computation.
                    },
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "inferenceSessionReference": "str",  # Optional. ID of a running inference
                      session that will be used for the evaluation instead of starting a new one.
                    "kind": "Evaluation",  # Optional. Default value is "Evaluation". Kind.
                      "Evaluation"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "replications": 1,  # Optional. Default value is 1. Number of replications to
                      run.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str",  # Optional. Top-level resource status (assigned by system).
                    "workersPerReplica": 0  # Optional. Number of data workers per inference
                      service replica.
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create an Evaluation.

        Create an Evaluation.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "dataset": "str",  # The Dataset to evaluate on. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "inferenceSession": {
                        "inferenceService": {
                            "account": "str",  # Account that owns the entity. Required.
                            "id": "str",  # Unique identifier of the entity. Required.
                            "interface": {
                                "endpoint": "str",  # HTTP endpoint for inference.
                                  Required.
                                "outputSchema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ]
                            },
                            "name": "str",  # The name of the service. Required.
                            "builder": {
                                "kind": "str",  # Kind. Required.
                                "args": [
                                    "str"  # Optional. Args.
                                ]
                            },
                            "model": {
                                "account": "str",  # Account that owns the entity.
                                  Required.
                                "artifact": {
                                    "kind": "str",  # How the model data is
                                      represented. Required. "HuggingFaceCache"
                                    "huggingFaceCache": {
                                        "repoID": "str",  # Name of the model
                                          in the HuggingFace cache. Required.
                                        "revision": "str"  # Model revision.
                                          Required.
                                    }
                                },
                                "id": "str",  # Unique identifier of the entity.
                                  Required.
                                "name": "str",  # The name of the Model. Required.
                                "storage": {
                                    "medium": "str"  # Storage medium. Required.
                                      Known values are: "ObjectStorage" and "PersistentVolume".
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",  # Unique ID of the DataView.
                                      Required.
                                    "schema": {
                                        "arrowSchema": "str",  # The schema
                                          in Arrow format, encoded with
                                          dyff.schema.arrow.encode_schema(). This is required, but can
                                          be populated from a DyffDataSchema. Required.
                                        "dyffSchema": {
                                            "components": [
                                                "str"  # A list of
                                                  named dyff data schemas. The final schema is the
                                                  composition of these component schemas. Required.
                                            ],
                                            "schemaVersion": "0.1"  #
                                              Optional. Default value is "0.1". The dyff schema
                                              version. "0.1"
                                        },
                                        "jsonSchema": {}  # Optional. The
                                          schema in JSON Schema format.
                                    },
                                    "viewOf": "str",  # ID of the resource that
                                      this is a view of. Required.
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",  # Name of a
                                              schema adapter available on the platform. Required.
                                            "configuration": {}  #
                                              Optional. Configuration for the schema adapter. Must be
                                              encodable as JSON.
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",  # An enumeration. Required. Known
                                  values are: "bentoml_service_openllm", "huggingface", "mock",
                                  "standalone", and "vllm".
                                "resources": {
                                    "storage": "str",  # Amount of storage
                                      required for packaged model, in k8s Quantity notation. Required.
                                    "memory": "str"  # Optional. Amount of memory
                                      required to run the model on CPU, in k8s Quantity notation.
                                },
                                "accelerator": {
                                    "kind": "str",  # The kind of accelerator;
                                      available kinds are {{GPU}}. Required.
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"  # Acceptable GPU
                                              hardware types. Required.
                                        ],
                                        "count": 1,  # Optional. Default
                                          value is 1. Number of GPUs required.
                                        "memory": "str"  # Optional.
                                          [DEPRECATED] Amount of GPU memory required, in k8s Quantity
                                          notation.
                                    }
                                },
                                "args": [
                                    "str"  # Optional. Command line arguments to
                                      forward to the runner.
                                ],
                                "image": {
                                    "digest": "str",  # The digest of the image.
                                      The image is always pulled by digest, even if 'tag' is specified.
                                      Required.
                                    "host": "str",  # The host of the container
                                      image registry. Required.
                                    "name": "str",  # The name of the image.
                                      Required.
                                    "tag": "str"  # Optional. The tag of the
                                      image. Although the image is always pulled by digest, including
                                      the tag is strongly recommended as it is often the main source of
                                      versioning information.
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "expires": "2020-02-20 00:00:00",  # Optional. Expiration time for
                          the session. Use of this field is recommended to avoid accidental compute
                          costs.
                        "replicas": 1,  # Optional. Default value is 1. Number of model
                          replicas.
                        "useSpotPods": True  # Optional. Default value is True. Use 'spot
                          pods' for cheaper computation.
                    },
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "inferenceSessionReference": "str",  # Optional. ID of a running inference
                      session that will be used for the evaluation instead of starting a new one.
                    "kind": "Evaluation",  # Optional. Default value is "Evaluation". Kind.
                      "Evaluation"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "replications": 1,  # Optional. Default value is 1. Number of replications to
                      run.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str",  # Optional. Top-level resource status (assigned by system).
                    "workersPerReplica": 0  # Optional. Number of data workers per inference
                      service replica.
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create an Evaluation.

        Create an Evaluation.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "dataset": "str",  # The Dataset to evaluate on. Required.
                    "inferenceSession": {
                        "inferenceService": "str",  # InferenceService ID. Required.
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "expires": "2020-02-20 00:00:00",  # Optional. Expiration time for
                          the session. Use of this field is recommended to avoid accidental compute
                          costs.
                        "replicas": 1,  # Optional. Default value is 1. Number of model
                          replicas.
                        "useSpotPods": True  # Optional. Default value is True. Use 'spot
                          pods' for cheaper computation.
                    },
                    "inferenceSessionReference": "str",  # Optional. The ID of a running
                      inference session that will be used for the evaluation, instead of starting a new
                      one.
                    "replications": 1,  # Optional. Default value is 1. Number of replications to
                      run.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "workersPerReplica": 0  # Optional. Number of data workers per inference
                      service replica.
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "dataset": "str",  # The Dataset to evaluate on. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "inferenceSession": {
                        "inferenceService": {
                            "account": "str",  # Account that owns the entity. Required.
                            "id": "str",  # Unique identifier of the entity. Required.
                            "interface": {
                                "endpoint": "str",  # HTTP endpoint for inference.
                                  Required.
                                "outputSchema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ]
                            },
                            "name": "str",  # The name of the service. Required.
                            "builder": {
                                "kind": "str",  # Kind. Required.
                                "args": [
                                    "str"  # Optional. Args.
                                ]
                            },
                            "model": {
                                "account": "str",  # Account that owns the entity.
                                  Required.
                                "artifact": {
                                    "kind": "str",  # How the model data is
                                      represented. Required. "HuggingFaceCache"
                                    "huggingFaceCache": {
                                        "repoID": "str",  # Name of the model
                                          in the HuggingFace cache. Required.
                                        "revision": "str"  # Model revision.
                                          Required.
                                    }
                                },
                                "id": "str",  # Unique identifier of the entity.
                                  Required.
                                "name": "str",  # The name of the Model. Required.
                                "storage": {
                                    "medium": "str"  # Storage medium. Required.
                                      Known values are: "ObjectStorage" and "PersistentVolume".
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",  # Unique ID of the DataView.
                                      Required.
                                    "schema": {
                                        "arrowSchema": "str",  # The schema
                                          in Arrow format, encoded with
                                          dyff.schema.arrow.encode_schema(). This is required, but can
                                          be populated from a DyffDataSchema. Required.
                                        "dyffSchema": {
                                            "components": [
                                                "str"  # A list of
                                                  named dyff data schemas. The final schema is the
                                                  composition of these component schemas. Required.
                                            ],
                                            "schemaVersion": "0.1"  #
                                              Optional. Default value is "0.1". The dyff schema
                                              version. "0.1"
                                        },
                                        "jsonSchema": {}  # Optional. The
                                          schema in JSON Schema format.
                                    },
                                    "viewOf": "str",  # ID of the resource that
                                      this is a view of. Required.
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",  # Name of a
                                              schema adapter available on the platform. Required.
                                            "configuration": {}  #
                                              Optional. Configuration for the schema adapter. Must be
                                              encodable as JSON.
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",  # An enumeration. Required. Known
                                  values are: "bentoml_service_openllm", "huggingface", "mock",
                                  "standalone", and "vllm".
                                "resources": {
                                    "storage": "str",  # Amount of storage
                                      required for packaged model, in k8s Quantity notation. Required.
                                    "memory": "str"  # Optional. Amount of memory
                                      required to run the model on CPU, in k8s Quantity notation.
                                },
                                "accelerator": {
                                    "kind": "str",  # The kind of accelerator;
                                      available kinds are {{GPU}}. Required.
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"  # Acceptable GPU
                                              hardware types. Required.
                                        ],
                                        "count": 1,  # Optional. Default
                                          value is 1. Number of GPUs required.
                                        "memory": "str"  # Optional.
                                          [DEPRECATED] Amount of GPU memory required, in k8s Quantity
                                          notation.
                                    }
                                },
                                "args": [
                                    "str"  # Optional. Command line arguments to
                                      forward to the runner.
                                ],
                                "image": {
                                    "digest": "str",  # The digest of the image.
                                      The image is always pulled by digest, even if 'tag' is specified.
                                      Required.
                                    "host": "str",  # The host of the container
                                      image registry. Required.
                                    "name": "str",  # The name of the image.
                                      Required.
                                    "tag": "str"  # Optional. The tag of the
                                      image. Although the image is always pulled by digest, including
                                      the tag is strongly recommended as it is often the main source of
                                      versioning information.
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "expires": "2020-02-20 00:00:00",  # Optional. Expiration time for
                          the session. Use of this field is recommended to avoid accidental compute
                          costs.
                        "replicas": 1,  # Optional. Default value is 1. Number of model
                          replicas.
                        "useSpotPods": True  # Optional. Default value is True. Use 'spot
                          pods' for cheaper computation.
                    },
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "inferenceSessionReference": "str",  # Optional. ID of a running inference
                      session that will be used for the evaluation instead of starting a new one.
                    "kind": "Evaluation",  # Optional. Default value is "Evaluation". Kind.
                      "Evaluation"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "replications": 1,  # Optional. Default value is 1. Number of replications to
                      run.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str",  # Optional. Top-level resource status (assigned by system).
                    "workersPerReplica": 0  # Optional. Number of data workers per inference
                      service replica.
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_evaluations_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get(self, evaluation_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get an Evaluation by its key.

        Get an Evaluation by its key.

        Raises a 404 error if no entity exists with that key.

        :param evaluation_id: Required.
        :type evaluation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "dataset": "str",  # The Dataset to evaluate on. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "inferenceSession": {
                        "inferenceService": {
                            "account": "str",  # Account that owns the entity. Required.
                            "id": "str",  # Unique identifier of the entity. Required.
                            "interface": {
                                "endpoint": "str",  # HTTP endpoint for inference.
                                  Required.
                                "outputSchema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ]
                            },
                            "name": "str",  # The name of the service. Required.
                            "builder": {
                                "kind": "str",  # Kind. Required.
                                "args": [
                                    "str"  # Optional. Args.
                                ]
                            },
                            "model": {
                                "account": "str",  # Account that owns the entity.
                                  Required.
                                "artifact": {
                                    "kind": "str",  # How the model data is
                                      represented. Required. "HuggingFaceCache"
                                    "huggingFaceCache": {
                                        "repoID": "str",  # Name of the model
                                          in the HuggingFace cache. Required.
                                        "revision": "str"  # Model revision.
                                          Required.
                                    }
                                },
                                "id": "str",  # Unique identifier of the entity.
                                  Required.
                                "name": "str",  # The name of the Model. Required.
                                "storage": {
                                    "medium": "str"  # Storage medium. Required.
                                      Known values are: "ObjectStorage" and "PersistentVolume".
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",  # Unique ID of the DataView.
                                      Required.
                                    "schema": {
                                        "arrowSchema": "str",  # The schema
                                          in Arrow format, encoded with
                                          dyff.schema.arrow.encode_schema(). This is required, but can
                                          be populated from a DyffDataSchema. Required.
                                        "dyffSchema": {
                                            "components": [
                                                "str"  # A list of
                                                  named dyff data schemas. The final schema is the
                                                  composition of these component schemas. Required.
                                            ],
                                            "schemaVersion": "0.1"  #
                                              Optional. Default value is "0.1". The dyff schema
                                              version. "0.1"
                                        },
                                        "jsonSchema": {}  # Optional. The
                                          schema in JSON Schema format.
                                    },
                                    "viewOf": "str",  # ID of the resource that
                                      this is a view of. Required.
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",  # Name of a
                                              schema adapter available on the platform. Required.
                                            "configuration": {}  #
                                              Optional. Configuration for the schema adapter. Must be
                                              encodable as JSON.
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",  # An enumeration. Required. Known
                                  values are: "bentoml_service_openllm", "huggingface", "mock",
                                  "standalone", and "vllm".
                                "resources": {
                                    "storage": "str",  # Amount of storage
                                      required for packaged model, in k8s Quantity notation. Required.
                                    "memory": "str"  # Optional. Amount of memory
                                      required to run the model on CPU, in k8s Quantity notation.
                                },
                                "accelerator": {
                                    "kind": "str",  # The kind of accelerator;
                                      available kinds are {{GPU}}. Required.
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"  # Acceptable GPU
                                              hardware types. Required.
                                        ],
                                        "count": 1,  # Optional. Default
                                          value is 1. Number of GPUs required.
                                        "memory": "str"  # Optional.
                                          [DEPRECATED] Amount of GPU memory required, in k8s Quantity
                                          notation.
                                    }
                                },
                                "args": [
                                    "str"  # Optional. Command line arguments to
                                      forward to the runner.
                                ],
                                "image": {
                                    "digest": "str",  # The digest of the image.
                                      The image is always pulled by digest, even if 'tag' is specified.
                                      Required.
                                    "host": "str",  # The host of the container
                                      image registry. Required.
                                    "name": "str",  # The name of the image.
                                      Required.
                                    "tag": "str"  # Optional. The tag of the
                                      image. Although the image is always pulled by digest, including
                                      the tag is strongly recommended as it is often the main source of
                                      versioning information.
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "expires": "2020-02-20 00:00:00",  # Optional. Expiration time for
                          the session. Use of this field is recommended to avoid accidental compute
                          costs.
                        "replicas": 1,  # Optional. Default value is 1. Number of model
                          replicas.
                        "useSpotPods": True  # Optional. Default value is True. Use 'spot
                          pods' for cheaper computation.
                    },
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "inferenceSessionReference": "str",  # Optional. ID of a running inference
                      session that will be used for the evaluation instead of starting a new one.
                    "kind": "Evaluation",  # Optional. Default value is "Evaluation". Kind.
                      "Evaluation"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "replications": 1,  # Optional. Default value is 1. Number of replications to
                      run.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str",  # Optional. Top-level resource status (assigned by system).
                    "workersPerReplica": 0  # Optional. Number of data workers per inference
                      service replica.
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_evaluations_get_request(
            evaluation_id=evaluation_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete(self, evaluation_id: str, **kwargs: Any) -> JSON:
        """Mark an Evaluation for deletion.

        Mark an Evaluation for deletion.

        :param evaluation_id: Required.
        :type evaluation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_evaluations_delete_request(
            evaluation_id=evaluation_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def downlinks(
        self, evaluation_id: str, **kwargs: Any
    ) -> Union[List[JSON], JSON]:
        """Get a list of signed GET URLs from which Evaluation artifacts can be
        downloaded.

        Get a list of signed GET URLs from which Evaluation artifacts can be downloaded.

        :param evaluation_id: Required.
        :type evaluation_id: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "artifact": {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        },
                        "signedURL": {
                            "method": "str",  # The HTTP method applicable to the URL.
                              Required.
                            "url": "str",  # The signed URL. Required.
                            "headers": {
                                "str": "str"  # Optional. Mandatory headers that must
                                  be passed with the request.
                            }
                        }
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_evaluations_downlinks_request(
            evaluation_id=evaluation_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore


class InferenceservicesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.aio.DyffV0API`'s
        :attr:`inferenceservices` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    async def label(
        self,
        service_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing InferenceService.

        Update labels for an existing InferenceService.

        :param service_id: Required.
        :type service_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def label(
        self,
        service_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        """Update labels for an existing InferenceService.

        Update labels for an existing InferenceService.

        :param service_id: Required.
        :type service_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def label(
        self, service_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing InferenceService.

        Update labels for an existing InferenceService.

        :param service_id: Required.
        :type service_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_inferenceservices_label_request(
            service_id=service_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        name: Optional[str] = None,
        model: Optional[str] = None,
        model_name: Optional[str] = None,
        **kwargs: Any,
    ) -> Union[List[JSON], JSON]:
        # pylint: disable=line-too-long
        """Get all InferenceServices matching a query.

        Get all InferenceServices matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword model: Default value is None.
        :paramtype model: str
        :keyword model_name: Default value is None.
        :paramtype model_name: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "interface": {
                            "endpoint": "str",  # HTTP endpoint for inference. Required.
                            "outputSchema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "inputPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ],
                            "outputPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        },
                        "name": "str",  # The name of the service. Required.
                        "annotations": [
                            {
                                "key": "str",  # The annotation key. A DNS label with
                                  an optional DNS domain prefix. For example: 'my-key',
                                  'your.com/key_0'. Names prefixed with 'dyff.io/',
                                  'subdomain.dyff.io/', etc. are reserved.  See
                                  https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                                  for detailed naming rules. Required.
                                "value": "str"  # The annotation value. An arbitrary
                                  string. Required.
                            }
                        ],
                        "builder": {
                            "kind": "str",  # Kind. Required.
                            "args": [
                                "str"  # Optional. Args.
                            ]
                        },
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation
                          time (assigned by system).
                        "kind": "InferenceService",  # Optional. Default value is
                          "InferenceService". Kind. "InferenceService"
                        "labels": {
                            "str": "str"  # Optional. A set of key-value labels for the
                              resource. Used to specify identifying attributes of resources that are
                              meaningful to users but do not imply semantics in the dyff system.  The
                              keys are DNS labels with an optional DNS domain prefix. For example:
                              'my-key', 'your.com/key_0'. Keys prefixed with 'dyff.io/',
                              'subdomain.dyff.io/', etc. are reserved.  The label values are
                              alphanumeric characters separated by '.', '-', or '_'.  We follow the
                              kubernetes label conventions closely. See:
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                        },
                        "model": {
                            "account": "str",  # Account that owns the entity. Required.
                            "artifact": {
                                "kind": "str",  # How the model data is represented.
                                  Required. "HuggingFaceCache"
                                "huggingFaceCache": {
                                    "repoID": "str",  # Name of the model in the
                                      HuggingFace cache. Required.
                                    "revision": "str"  # Model revision.
                                      Required.
                                }
                            },
                            "id": "str",  # Unique identifier of the entity. Required.
                            "name": "str",  # The name of the Model. Required.
                            "storage": {
                                "medium": "str"  # Storage medium. Required. Known
                                  values are: "ObjectStorage" and "PersistentVolume".
                            }
                        },
                        "outputViews": [
                            {
                                "id": "str",  # Unique ID of the DataView. Required.
                                "schema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "viewOf": "str",  # ID of the resource that this is a
                                  view of. Required.
                                "adapterPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ]
                            }
                        ],
                        "reason": "str",  # Optional. Reason for current status (assigned by
                          system).
                        "runner": {
                            "kind": "str",  # An enumeration. Required. Known values are:
                              "bentoml_service_openllm", "huggingface", "mock", "standalone", and
                              "vllm".
                            "resources": {
                                "storage": "str",  # Amount of storage required for
                                  packaged model, in k8s Quantity notation. Required.
                                "memory": "str"  # Optional. Amount of memory
                                  required to run the model on CPU, in k8s Quantity notation.
                            },
                            "accelerator": {
                                "kind": "str",  # The kind of accelerator; available
                                  kinds are {{GPU}}. Required.
                                "gpu": {
                                    "hardwareTypes": [
                                        "str"  # Acceptable GPU hardware
                                          types. Required.
                                    ],
                                    "count": 1,  # Optional. Default value is 1.
                                      Number of GPUs required.
                                    "memory": "str"  # Optional. [DEPRECATED]
                                      Amount of GPU memory required, in k8s Quantity notation.
                                }
                            },
                            "args": [
                                "str"  # Optional. Command line arguments to forward
                                  to the runner.
                            ],
                            "image": {
                                "digest": "str",  # The digest of the image. The
                                  image is always pulled by digest, even if 'tag' is specified.
                                  Required.
                                "host": "str",  # The host of the container image
                                  registry. Required.
                                "name": "str",  # The name of the image. Required.
                                "tag": "str"  # Optional. The tag of the image.
                                  Although the image is always pulled by digest, including the tag is
                                  strongly recommended as it is often the main source of versioning
                                  information.
                            }
                        },
                        "schemaVersion": "0.1",  # Optional. Default value is "0.1". The
                          schema version. "0.1"
                        "status": "str"  # Optional. Top-level resource status (assigned by
                          system).
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_inferenceservices_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            name=name,
            model=model,
            model_name=model_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create an InferenceService.

        Create an InferenceService.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "interface": {
                        "endpoint": "str",  # HTTP endpoint for inference. Required.
                        "outputSchema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "inputPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ],
                        "outputPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "name": "str",  # The name of the service. Required.
                    "builder": {
                        "kind": "str",  # Kind. Required.
                        "args": [
                            "str"  # Optional. Args.
                        ]
                    },
                    "model": "str",  # Optional. ID of Model backing the service, if applicable.
                    "outputViews": [
                        {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        }
                    ],
                    "runner": {
                        "kind": "str",  # An enumeration. Required. Known values are:
                          "bentoml_service_openllm", "huggingface", "mock", "standalone", and "vllm".
                        "resources": {
                            "storage": "str",  # Amount of storage required for packaged
                              model, in k8s Quantity notation. Required.
                            "memory": "str"  # Optional. Amount of memory required to run
                              the model on CPU, in k8s Quantity notation.
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "args": [
                            "str"  # Optional. Command line arguments to forward to the
                              runner.
                        ],
                        "image": {
                            "digest": "str",  # The digest of the image. The image is
                              always pulled by digest, even if 'tag' is specified. Required.
                            "host": "str",  # The host of the container image registry.
                              Required.
                            "name": "str",  # The name of the image. Required.
                            "tag": "str"  # Optional. The tag of the image. Although the
                              image is always pulled by digest, including the tag is strongly
                              recommended as it is often the main source of versioning information.
                        }
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "interface": {
                        "endpoint": "str",  # HTTP endpoint for inference. Required.
                        "outputSchema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "inputPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ],
                        "outputPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "name": "str",  # The name of the service. Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "builder": {
                        "kind": "str",  # Kind. Required.
                        "args": [
                            "str"  # Optional. Args.
                        ]
                    },
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "InferenceService",  # Optional. Default value is "InferenceService".
                      Kind. "InferenceService"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "model": {
                        "account": "str",  # Account that owns the entity. Required.
                        "artifact": {
                            "kind": "str",  # How the model data is represented.
                              Required. "HuggingFaceCache"
                            "huggingFaceCache": {
                                "repoID": "str",  # Name of the model in the
                                  HuggingFace cache. Required.
                                "revision": "str"  # Model revision. Required.
                            }
                        },
                        "id": "str",  # Unique identifier of the entity. Required.
                        "name": "str",  # The name of the Model. Required.
                        "storage": {
                            "medium": "str"  # Storage medium. Required. Known values
                              are: "ObjectStorage" and "PersistentVolume".
                        }
                    },
                    "outputViews": [
                        {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        }
                    ],
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "runner": {
                        "kind": "str",  # An enumeration. Required. Known values are:
                          "bentoml_service_openllm", "huggingface", "mock", "standalone", and "vllm".
                        "resources": {
                            "storage": "str",  # Amount of storage required for packaged
                              model, in k8s Quantity notation. Required.
                            "memory": "str"  # Optional. Amount of memory required to run
                              the model on CPU, in k8s Quantity notation.
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "args": [
                            "str"  # Optional. Command line arguments to forward to the
                              runner.
                        ],
                        "image": {
                            "digest": "str",  # The digest of the image. The image is
                              always pulled by digest, even if 'tag' is specified. Required.
                            "host": "str",  # The host of the container image registry.
                              Required.
                            "name": "str",  # The name of the image. Required.
                            "tag": "str"  # Optional. The tag of the image. Although the
                              image is always pulled by digest, including the tag is strongly
                              recommended as it is often the main source of versioning information.
                        }
                    },
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create an InferenceService.

        Create an InferenceService.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "interface": {
                        "endpoint": "str",  # HTTP endpoint for inference. Required.
                        "outputSchema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "inputPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ],
                        "outputPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "name": "str",  # The name of the service. Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "builder": {
                        "kind": "str",  # Kind. Required.
                        "args": [
                            "str"  # Optional. Args.
                        ]
                    },
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "InferenceService",  # Optional. Default value is "InferenceService".
                      Kind. "InferenceService"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "model": {
                        "account": "str",  # Account that owns the entity. Required.
                        "artifact": {
                            "kind": "str",  # How the model data is represented.
                              Required. "HuggingFaceCache"
                            "huggingFaceCache": {
                                "repoID": "str",  # Name of the model in the
                                  HuggingFace cache. Required.
                                "revision": "str"  # Model revision. Required.
                            }
                        },
                        "id": "str",  # Unique identifier of the entity. Required.
                        "name": "str",  # The name of the Model. Required.
                        "storage": {
                            "medium": "str"  # Storage medium. Required. Known values
                              are: "ObjectStorage" and "PersistentVolume".
                        }
                    },
                    "outputViews": [
                        {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        }
                    ],
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "runner": {
                        "kind": "str",  # An enumeration. Required. Known values are:
                          "bentoml_service_openllm", "huggingface", "mock", "standalone", and "vllm".
                        "resources": {
                            "storage": "str",  # Amount of storage required for packaged
                              model, in k8s Quantity notation. Required.
                            "memory": "str"  # Optional. Amount of memory required to run
                              the model on CPU, in k8s Quantity notation.
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "args": [
                            "str"  # Optional. Command line arguments to forward to the
                              runner.
                        ],
                        "image": {
                            "digest": "str",  # The digest of the image. The image is
                              always pulled by digest, even if 'tag' is specified. Required.
                            "host": "str",  # The host of the container image registry.
                              Required.
                            "name": "str",  # The name of the image. Required.
                            "tag": "str"  # Optional. The tag of the image. Although the
                              image is always pulled by digest, including the tag is strongly
                              recommended as it is often the main source of versioning information.
                        }
                    },
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create an InferenceService.

        Create an InferenceService.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "interface": {
                        "endpoint": "str",  # HTTP endpoint for inference. Required.
                        "outputSchema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "inputPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ],
                        "outputPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "name": "str",  # The name of the service. Required.
                    "builder": {
                        "kind": "str",  # Kind. Required.
                        "args": [
                            "str"  # Optional. Args.
                        ]
                    },
                    "model": "str",  # Optional. ID of Model backing the service, if applicable.
                    "outputViews": [
                        {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        }
                    ],
                    "runner": {
                        "kind": "str",  # An enumeration. Required. Known values are:
                          "bentoml_service_openllm", "huggingface", "mock", "standalone", and "vllm".
                        "resources": {
                            "storage": "str",  # Amount of storage required for packaged
                              model, in k8s Quantity notation. Required.
                            "memory": "str"  # Optional. Amount of memory required to run
                              the model on CPU, in k8s Quantity notation.
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "args": [
                            "str"  # Optional. Command line arguments to forward to the
                              runner.
                        ],
                        "image": {
                            "digest": "str",  # The digest of the image. The image is
                              always pulled by digest, even if 'tag' is specified. Required.
                            "host": "str",  # The host of the container image registry.
                              Required.
                            "name": "str",  # The name of the image. Required.
                            "tag": "str"  # Optional. The tag of the image. Although the
                              image is always pulled by digest, including the tag is strongly
                              recommended as it is often the main source of versioning information.
                        }
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "interface": {
                        "endpoint": "str",  # HTTP endpoint for inference. Required.
                        "outputSchema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "inputPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ],
                        "outputPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "name": "str",  # The name of the service. Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "builder": {
                        "kind": "str",  # Kind. Required.
                        "args": [
                            "str"  # Optional. Args.
                        ]
                    },
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "InferenceService",  # Optional. Default value is "InferenceService".
                      Kind. "InferenceService"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "model": {
                        "account": "str",  # Account that owns the entity. Required.
                        "artifact": {
                            "kind": "str",  # How the model data is represented.
                              Required. "HuggingFaceCache"
                            "huggingFaceCache": {
                                "repoID": "str",  # Name of the model in the
                                  HuggingFace cache. Required.
                                "revision": "str"  # Model revision. Required.
                            }
                        },
                        "id": "str",  # Unique identifier of the entity. Required.
                        "name": "str",  # The name of the Model. Required.
                        "storage": {
                            "medium": "str"  # Storage medium. Required. Known values
                              are: "ObjectStorage" and "PersistentVolume".
                        }
                    },
                    "outputViews": [
                        {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        }
                    ],
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "runner": {
                        "kind": "str",  # An enumeration. Required. Known values are:
                          "bentoml_service_openllm", "huggingface", "mock", "standalone", and "vllm".
                        "resources": {
                            "storage": "str",  # Amount of storage required for packaged
                              model, in k8s Quantity notation. Required.
                            "memory": "str"  # Optional. Amount of memory required to run
                              the model on CPU, in k8s Quantity notation.
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "args": [
                            "str"  # Optional. Command line arguments to forward to the
                              runner.
                        ],
                        "image": {
                            "digest": "str",  # The digest of the image. The image is
                              always pulled by digest, even if 'tag' is specified. Required.
                            "host": "str",  # The host of the container image registry.
                              Required.
                            "name": "str",  # The name of the image. Required.
                            "tag": "str"  # Optional. The tag of the image. Although the
                              image is always pulled by digest, including the tag is strongly
                              recommended as it is often the main source of versioning information.
                        }
                    },
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_inferenceservices_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get(self, service_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get an InferenceService by its key.

        Get an InferenceService by its key.

        Raises a 404 error if no entity exists with that key.

        :param service_id: Required.
        :type service_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "interface": {
                        "endpoint": "str",  # HTTP endpoint for inference. Required.
                        "outputSchema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "inputPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ],
                        "outputPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "name": "str",  # The name of the service. Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "builder": {
                        "kind": "str",  # Kind. Required.
                        "args": [
                            "str"  # Optional. Args.
                        ]
                    },
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "InferenceService",  # Optional. Default value is "InferenceService".
                      Kind. "InferenceService"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "model": {
                        "account": "str",  # Account that owns the entity. Required.
                        "artifact": {
                            "kind": "str",  # How the model data is represented.
                              Required. "HuggingFaceCache"
                            "huggingFaceCache": {
                                "repoID": "str",  # Name of the model in the
                                  HuggingFace cache. Required.
                                "revision": "str"  # Model revision. Required.
                            }
                        },
                        "id": "str",  # Unique identifier of the entity. Required.
                        "name": "str",  # The name of the Model. Required.
                        "storage": {
                            "medium": "str"  # Storage medium. Required. Known values
                              are: "ObjectStorage" and "PersistentVolume".
                        }
                    },
                    "outputViews": [
                        {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        }
                    ],
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "runner": {
                        "kind": "str",  # An enumeration. Required. Known values are:
                          "bentoml_service_openllm", "huggingface", "mock", "standalone", and "vllm".
                        "resources": {
                            "storage": "str",  # Amount of storage required for packaged
                              model, in k8s Quantity notation. Required.
                            "memory": "str"  # Optional. Amount of memory required to run
                              the model on CPU, in k8s Quantity notation.
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "args": [
                            "str"  # Optional. Command line arguments to forward to the
                              runner.
                        ],
                        "image": {
                            "digest": "str",  # The digest of the image. The image is
                              always pulled by digest, even if 'tag' is specified. Required.
                            "host": "str",  # The host of the container image registry.
                              Required.
                            "name": "str",  # The name of the image. Required.
                            "tag": "str"  # Optional. The tag of the image. Although the
                              image is always pulled by digest, including the tag is strongly
                              recommended as it is often the main source of versioning information.
                        }
                    },
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_inferenceservices_get_request(
            service_id=service_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete(self, service_id: str, **kwargs: Any) -> JSON:
        """Mark an InferenceService for deletion.

        Mark an InferenceService for deletion.

        :param service_id: Required.
        :type service_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_inferenceservices_delete_request(
            service_id=service_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def documentation(self, service_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get the documentation associated with an InferenceService.

        Get the documentation associated with an InferenceService.

        Raises a 404 error if no entity exists with that key.

        :param service_id: Required.
        :type service_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_inferenceservices_documentation_request(
            service_id=service_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def edit_documentation(
        self,
        service_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with an InferenceService.

        Edit the documentation associated with an InferenceService.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param service_id: Required.
        :type service_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def edit_documentation(
        self,
        service_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with an InferenceService.

        Edit the documentation associated with an InferenceService.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param service_id: Required.
        :type service_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def edit_documentation(
        self, service_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with an InferenceService.

        Edit the documentation associated with an InferenceService.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param service_id: Required.
        :type service_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_inferenceservices_edit_documentation_request(
            service_id=service_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class InferencesessionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.aio.DyffV0API`'s
        :attr:`inferencesessions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    async def label(
        self,
        session_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing InferenceSession.

        Update labels for an existing InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def label(
        self,
        session_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        """Update labels for an existing InferenceSession.

        Update labels for an existing InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def label(
        self, session_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing InferenceSession.

        Update labels for an existing InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_inferencesessions_label_request(
            session_id=session_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        name: Optional[str] = None,
        inference_service: Optional[str] = None,
        inference_service_name: Optional[str] = None,
        model: Optional[str] = None,
        model_name: Optional[str] = None,
        **kwargs: Any,
    ) -> Union[List[JSON], JSON]:
        # pylint: disable=line-too-long
        """Get all InferenceSessions matching a query.

        Get all InferenceSessions matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword inference_service: Default value is None.
        :paramtype inference_service: str
        :keyword inference_service_name: Default value is None.
        :paramtype inference_service_name: str
        :keyword model: Default value is None.
        :paramtype model: str
        :keyword model_name: Default value is None.
        :paramtype model_name: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "inferenceService": {
                            "account": "str",  # Account that owns the entity. Required.
                            "id": "str",  # Unique identifier of the entity. Required.
                            "interface": {
                                "endpoint": "str",  # HTTP endpoint for inference.
                                  Required.
                                "outputSchema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ]
                            },
                            "name": "str",  # The name of the service. Required.
                            "builder": {
                                "kind": "str",  # Kind. Required.
                                "args": [
                                    "str"  # Optional. Args.
                                ]
                            },
                            "model": {
                                "account": "str",  # Account that owns the entity.
                                  Required.
                                "artifact": {
                                    "kind": "str",  # How the model data is
                                      represented. Required. "HuggingFaceCache"
                                    "huggingFaceCache": {
                                        "repoID": "str",  # Name of the model
                                          in the HuggingFace cache. Required.
                                        "revision": "str"  # Model revision.
                                          Required.
                                    }
                                },
                                "id": "str",  # Unique identifier of the entity.
                                  Required.
                                "name": "str",  # The name of the Model. Required.
                                "storage": {
                                    "medium": "str"  # Storage medium. Required.
                                      Known values are: "ObjectStorage" and "PersistentVolume".
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",  # Unique ID of the DataView.
                                      Required.
                                    "schema": {
                                        "arrowSchema": "str",  # The schema
                                          in Arrow format, encoded with
                                          dyff.schema.arrow.encode_schema(). This is required, but can
                                          be populated from a DyffDataSchema. Required.
                                        "dyffSchema": {
                                            "components": [
                                                "str"  # A list of
                                                  named dyff data schemas. The final schema is the
                                                  composition of these component schemas. Required.
                                            ],
                                            "schemaVersion": "0.1"  #
                                              Optional. Default value is "0.1". The dyff schema
                                              version. "0.1"
                                        },
                                        "jsonSchema": {}  # Optional. The
                                          schema in JSON Schema format.
                                    },
                                    "viewOf": "str",  # ID of the resource that
                                      this is a view of. Required.
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",  # Name of a
                                              schema adapter available on the platform. Required.
                                            "configuration": {}  #
                                              Optional. Configuration for the schema adapter. Must be
                                              encodable as JSON.
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",  # An enumeration. Required. Known
                                  values are: "bentoml_service_openllm", "huggingface", "mock",
                                  "standalone", and "vllm".
                                "resources": {
                                    "storage": "str",  # Amount of storage
                                      required for packaged model, in k8s Quantity notation. Required.
                                    "memory": "str"  # Optional. Amount of memory
                                      required to run the model on CPU, in k8s Quantity notation.
                                },
                                "accelerator": {
                                    "kind": "str",  # The kind of accelerator;
                                      available kinds are {{GPU}}. Required.
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"  # Acceptable GPU
                                              hardware types. Required.
                                        ],
                                        "count": 1,  # Optional. Default
                                          value is 1. Number of GPUs required.
                                        "memory": "str"  # Optional.
                                          [DEPRECATED] Amount of GPU memory required, in k8s Quantity
                                          notation.
                                    }
                                },
                                "args": [
                                    "str"  # Optional. Command line arguments to
                                      forward to the runner.
                                ],
                                "image": {
                                    "digest": "str",  # The digest of the image.
                                      The image is always pulled by digest, even if 'tag' is specified.
                                      Required.
                                    "host": "str",  # The host of the container
                                      image registry. Required.
                                    "name": "str",  # The name of the image.
                                      Required.
                                    "tag": "str"  # Optional. The tag of the
                                      image. Although the image is always pulled by digest, including
                                      the tag is strongly recommended as it is often the main source of
                                      versioning information.
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "annotations": [
                            {
                                "key": "str",  # The annotation key. A DNS label with
                                  an optional DNS domain prefix. For example: 'my-key',
                                  'your.com/key_0'. Names prefixed with 'dyff.io/',
                                  'subdomain.dyff.io/', etc. are reserved.  See
                                  https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                                  for detailed naming rules. Required.
                                "value": "str"  # The annotation value. An arbitrary
                                  string. Required.
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation
                          time (assigned by system).
                        "expires": "2020-02-20 00:00:00",  # Optional. Expiration time for
                          the session. Use of this field is recommended to avoid accidental compute
                          costs.
                        "kind": "InferenceSession",  # Optional. Default value is
                          "InferenceSession". Kind. "InferenceSession"
                        "labels": {
                            "str": "str"  # Optional. A set of key-value labels for the
                              resource. Used to specify identifying attributes of resources that are
                              meaningful to users but do not imply semantics in the dyff system.  The
                              keys are DNS labels with an optional DNS domain prefix. For example:
                              'my-key', 'your.com/key_0'. Keys prefixed with 'dyff.io/',
                              'subdomain.dyff.io/', etc. are reserved.  The label values are
                              alphanumeric characters separated by '.', '-', or '_'.  We follow the
                              kubernetes label conventions closely. See:
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                        },
                        "reason": "str",  # Optional. Reason for current status (assigned by
                          system).
                        "replicas": 1,  # Optional. Default value is 1. Number of model
                          replicas.
                        "schemaVersion": "0.1",  # Optional. Default value is "0.1". The
                          schema version. "0.1"
                        "status": "str",  # Optional. Top-level resource status (assigned by
                          system).
                        "useSpotPods": True  # Optional. Default value is True. Use 'spot
                          pods' for cheaper computation.
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_inferencesessions_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            name=name,
            inference_service=inference_service,
            inference_service_name=inference_service_name,
            model=model,
            model_name=model_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create an InferenceSession.

        Create an InferenceSession.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "inferenceService": "str",  # InferenceService ID. Required.
                    "accelerator": {
                        "kind": "str",  # The kind of accelerator; available kinds are
                          {{GPU}}. Required.
                        "gpu": {
                            "hardwareTypes": [
                                "str"  # Acceptable GPU hardware types. Required.
                            ],
                            "count": 1,  # Optional. Default value is 1. Number of GPUs
                              required.
                            "memory": "str"  # Optional. [DEPRECATED] Amount of GPU
                              memory required, in k8s Quantity notation.
                        }
                    },
                    "expires": "2020-02-20 00:00:00",  # Optional. Expiration time for the
                      session. Use of this field is recommended to avoid accidental compute costs.
                    "replicas": 1,  # Optional. Default value is 1. Number of model replicas.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "useSpotPods": True  # Optional. Default value is True. Use 'spot pods' for
                      cheaper computation.
                }

                # response body for status code(s): 200
                response == {
                    "inferencesession": {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "inferenceService": {
                            "account": "str",  # Account that owns the entity. Required.
                            "id": "str",  # Unique identifier of the entity. Required.
                            "interface": {
                                "endpoint": "str",  # HTTP endpoint for inference.
                                  Required.
                                "outputSchema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ]
                            },
                            "name": "str",  # The name of the service. Required.
                            "builder": {
                                "kind": "str",  # Kind. Required.
                                "args": [
                                    "str"  # Optional. Args.
                                ]
                            },
                            "model": {
                                "account": "str",  # Account that owns the entity.
                                  Required.
                                "artifact": {
                                    "kind": "str",  # How the model data is
                                      represented. Required. "HuggingFaceCache"
                                    "huggingFaceCache": {
                                        "repoID": "str",  # Name of the model
                                          in the HuggingFace cache. Required.
                                        "revision": "str"  # Model revision.
                                          Required.
                                    }
                                },
                                "id": "str",  # Unique identifier of the entity.
                                  Required.
                                "name": "str",  # The name of the Model. Required.
                                "storage": {
                                    "medium": "str"  # Storage medium. Required.
                                      Known values are: "ObjectStorage" and "PersistentVolume".
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",  # Unique ID of the DataView.
                                      Required.
                                    "schema": {
                                        "arrowSchema": "str",  # The schema
                                          in Arrow format, encoded with
                                          dyff.schema.arrow.encode_schema(). This is required, but can
                                          be populated from a DyffDataSchema. Required.
                                        "dyffSchema": {
                                            "components": [
                                                "str"  # A list of
                                                  named dyff data schemas. The final schema is the
                                                  composition of these component schemas. Required.
                                            ],
                                            "schemaVersion": "0.1"  #
                                              Optional. Default value is "0.1". The dyff schema
                                              version. "0.1"
                                        },
                                        "jsonSchema": {}  # Optional. The
                                          schema in JSON Schema format.
                                    },
                                    "viewOf": "str",  # ID of the resource that
                                      this is a view of. Required.
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",  # Name of a
                                              schema adapter available on the platform. Required.
                                            "configuration": {}  #
                                              Optional. Configuration for the schema adapter. Must be
                                              encodable as JSON.
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",  # An enumeration. Required. Known
                                  values are: "bentoml_service_openllm", "huggingface", "mock",
                                  "standalone", and "vllm".
                                "resources": {
                                    "storage": "str",  # Amount of storage
                                      required for packaged model, in k8s Quantity notation. Required.
                                    "memory": "str"  # Optional. Amount of memory
                                      required to run the model on CPU, in k8s Quantity notation.
                                },
                                "accelerator": {
                                    "kind": "str",  # The kind of accelerator;
                                      available kinds are {{GPU}}. Required.
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"  # Acceptable GPU
                                              hardware types. Required.
                                        ],
                                        "count": 1,  # Optional. Default
                                          value is 1. Number of GPUs required.
                                        "memory": "str"  # Optional.
                                          [DEPRECATED] Amount of GPU memory required, in k8s Quantity
                                          notation.
                                    }
                                },
                                "args": [
                                    "str"  # Optional. Command line arguments to
                                      forward to the runner.
                                ],
                                "image": {
                                    "digest": "str",  # The digest of the image.
                                      The image is always pulled by digest, even if 'tag' is specified.
                                      Required.
                                    "host": "str",  # The host of the container
                                      image registry. Required.
                                    "name": "str",  # The name of the image.
                                      Required.
                                    "tag": "str"  # Optional. The tag of the
                                      image. Although the image is always pulled by digest, including
                                      the tag is strongly recommended as it is often the main source of
                                      versioning information.
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "annotations": [
                            {
                                "key": "str",  # The annotation key. A DNS label with
                                  an optional DNS domain prefix. For example: 'my-key',
                                  'your.com/key_0'. Names prefixed with 'dyff.io/',
                                  'subdomain.dyff.io/', etc. are reserved.  See
                                  https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                                  for detailed naming rules. Required.
                                "value": "str"  # The annotation value. An arbitrary
                                  string. Required.
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation
                          time (assigned by system).
                        "expires": "2020-02-20 00:00:00",  # Optional. Expiration time for
                          the session. Use of this field is recommended to avoid accidental compute
                          costs.
                        "kind": "InferenceSession",  # Optional. Default value is
                          "InferenceSession". Kind. "InferenceSession"
                        "labels": {
                            "str": "str"  # Optional. A set of key-value labels for the
                              resource. Used to specify identifying attributes of resources that are
                              meaningful to users but do not imply semantics in the dyff system.  The
                              keys are DNS labels with an optional DNS domain prefix. For example:
                              'my-key', 'your.com/key_0'. Keys prefixed with 'dyff.io/',
                              'subdomain.dyff.io/', etc. are reserved.  The label values are
                              alphanumeric characters separated by '.', '-', or '_'.  We follow the
                              kubernetes label conventions closely. See:
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                        },
                        "reason": "str",  # Optional. Reason for current status (assigned by
                          system).
                        "replicas": 1,  # Optional. Default value is 1. Number of model
                          replicas.
                        "schemaVersion": "0.1",  # Optional. Default value is "0.1". The
                          schema version. "0.1"
                        "status": "str",  # Optional. Top-level resource status (assigned by
                          system).
                        "useSpotPods": True  # Optional. Default value is True. Use 'spot
                          pods' for cheaper computation.
                    },
                    "token": "str"  # Token. Required.
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create an InferenceSession.

        Create an InferenceSession.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "inferencesession": {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "inferenceService": {
                            "account": "str",  # Account that owns the entity. Required.
                            "id": "str",  # Unique identifier of the entity. Required.
                            "interface": {
                                "endpoint": "str",  # HTTP endpoint for inference.
                                  Required.
                                "outputSchema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ]
                            },
                            "name": "str",  # The name of the service. Required.
                            "builder": {
                                "kind": "str",  # Kind. Required.
                                "args": [
                                    "str"  # Optional. Args.
                                ]
                            },
                            "model": {
                                "account": "str",  # Account that owns the entity.
                                  Required.
                                "artifact": {
                                    "kind": "str",  # How the model data is
                                      represented. Required. "HuggingFaceCache"
                                    "huggingFaceCache": {
                                        "repoID": "str",  # Name of the model
                                          in the HuggingFace cache. Required.
                                        "revision": "str"  # Model revision.
                                          Required.
                                    }
                                },
                                "id": "str",  # Unique identifier of the entity.
                                  Required.
                                "name": "str",  # The name of the Model. Required.
                                "storage": {
                                    "medium": "str"  # Storage medium. Required.
                                      Known values are: "ObjectStorage" and "PersistentVolume".
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",  # Unique ID of the DataView.
                                      Required.
                                    "schema": {
                                        "arrowSchema": "str",  # The schema
                                          in Arrow format, encoded with
                                          dyff.schema.arrow.encode_schema(). This is required, but can
                                          be populated from a DyffDataSchema. Required.
                                        "dyffSchema": {
                                            "components": [
                                                "str"  # A list of
                                                  named dyff data schemas. The final schema is the
                                                  composition of these component schemas. Required.
                                            ],
                                            "schemaVersion": "0.1"  #
                                              Optional. Default value is "0.1". The dyff schema
                                              version. "0.1"
                                        },
                                        "jsonSchema": {}  # Optional. The
                                          schema in JSON Schema format.
                                    },
                                    "viewOf": "str",  # ID of the resource that
                                      this is a view of. Required.
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",  # Name of a
                                              schema adapter available on the platform. Required.
                                            "configuration": {}  #
                                              Optional. Configuration for the schema adapter. Must be
                                              encodable as JSON.
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",  # An enumeration. Required. Known
                                  values are: "bentoml_service_openllm", "huggingface", "mock",
                                  "standalone", and "vllm".
                                "resources": {
                                    "storage": "str",  # Amount of storage
                                      required for packaged model, in k8s Quantity notation. Required.
                                    "memory": "str"  # Optional. Amount of memory
                                      required to run the model on CPU, in k8s Quantity notation.
                                },
                                "accelerator": {
                                    "kind": "str",  # The kind of accelerator;
                                      available kinds are {{GPU}}. Required.
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"  # Acceptable GPU
                                              hardware types. Required.
                                        ],
                                        "count": 1,  # Optional. Default
                                          value is 1. Number of GPUs required.
                                        "memory": "str"  # Optional.
                                          [DEPRECATED] Amount of GPU memory required, in k8s Quantity
                                          notation.
                                    }
                                },
                                "args": [
                                    "str"  # Optional. Command line arguments to
                                      forward to the runner.
                                ],
                                "image": {
                                    "digest": "str",  # The digest of the image.
                                      The image is always pulled by digest, even if 'tag' is specified.
                                      Required.
                                    "host": "str",  # The host of the container
                                      image registry. Required.
                                    "name": "str",  # The name of the image.
                                      Required.
                                    "tag": "str"  # Optional. The tag of the
                                      image. Although the image is always pulled by digest, including
                                      the tag is strongly recommended as it is often the main source of
                                      versioning information.
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "annotations": [
                            {
                                "key": "str",  # The annotation key. A DNS label with
                                  an optional DNS domain prefix. For example: 'my-key',
                                  'your.com/key_0'. Names prefixed with 'dyff.io/',
                                  'subdomain.dyff.io/', etc. are reserved.  See
                                  https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                                  for detailed naming rules. Required.
                                "value": "str"  # The annotation value. An arbitrary
                                  string. Required.
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation
                          time (assigned by system).
                        "expires": "2020-02-20 00:00:00",  # Optional. Expiration time for
                          the session. Use of this field is recommended to avoid accidental compute
                          costs.
                        "kind": "InferenceSession",  # Optional. Default value is
                          "InferenceSession". Kind. "InferenceSession"
                        "labels": {
                            "str": "str"  # Optional. A set of key-value labels for the
                              resource. Used to specify identifying attributes of resources that are
                              meaningful to users but do not imply semantics in the dyff system.  The
                              keys are DNS labels with an optional DNS domain prefix. For example:
                              'my-key', 'your.com/key_0'. Keys prefixed with 'dyff.io/',
                              'subdomain.dyff.io/', etc. are reserved.  The label values are
                              alphanumeric characters separated by '.', '-', or '_'.  We follow the
                              kubernetes label conventions closely. See:
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                        },
                        "reason": "str",  # Optional. Reason for current status (assigned by
                          system).
                        "replicas": 1,  # Optional. Default value is 1. Number of model
                          replicas.
                        "schemaVersion": "0.1",  # Optional. Default value is "0.1". The
                          schema version. "0.1"
                        "status": "str",  # Optional. Top-level resource status (assigned by
                          system).
                        "useSpotPods": True  # Optional. Default value is True. Use 'spot
                          pods' for cheaper computation.
                    },
                    "token": "str"  # Token. Required.
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create an InferenceSession.

        Create an InferenceSession.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "inferenceService": "str",  # InferenceService ID. Required.
                    "accelerator": {
                        "kind": "str",  # The kind of accelerator; available kinds are
                          {{GPU}}. Required.
                        "gpu": {
                            "hardwareTypes": [
                                "str"  # Acceptable GPU hardware types. Required.
                            ],
                            "count": 1,  # Optional. Default value is 1. Number of GPUs
                              required.
                            "memory": "str"  # Optional. [DEPRECATED] Amount of GPU
                              memory required, in k8s Quantity notation.
                        }
                    },
                    "expires": "2020-02-20 00:00:00",  # Optional. Expiration time for the
                      session. Use of this field is recommended to avoid accidental compute costs.
                    "replicas": 1,  # Optional. Default value is 1. Number of model replicas.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "useSpotPods": True  # Optional. Default value is True. Use 'spot pods' for
                      cheaper computation.
                }

                # response body for status code(s): 200
                response == {
                    "inferencesession": {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "inferenceService": {
                            "account": "str",  # Account that owns the entity. Required.
                            "id": "str",  # Unique identifier of the entity. Required.
                            "interface": {
                                "endpoint": "str",  # HTTP endpoint for inference.
                                  Required.
                                "outputSchema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ]
                            },
                            "name": "str",  # The name of the service. Required.
                            "builder": {
                                "kind": "str",  # Kind. Required.
                                "args": [
                                    "str"  # Optional. Args.
                                ]
                            },
                            "model": {
                                "account": "str",  # Account that owns the entity.
                                  Required.
                                "artifact": {
                                    "kind": "str",  # How the model data is
                                      represented. Required. "HuggingFaceCache"
                                    "huggingFaceCache": {
                                        "repoID": "str",  # Name of the model
                                          in the HuggingFace cache. Required.
                                        "revision": "str"  # Model revision.
                                          Required.
                                    }
                                },
                                "id": "str",  # Unique identifier of the entity.
                                  Required.
                                "name": "str",  # The name of the Model. Required.
                                "storage": {
                                    "medium": "str"  # Storage medium. Required.
                                      Known values are: "ObjectStorage" and "PersistentVolume".
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",  # Unique ID of the DataView.
                                      Required.
                                    "schema": {
                                        "arrowSchema": "str",  # The schema
                                          in Arrow format, encoded with
                                          dyff.schema.arrow.encode_schema(). This is required, but can
                                          be populated from a DyffDataSchema. Required.
                                        "dyffSchema": {
                                            "components": [
                                                "str"  # A list of
                                                  named dyff data schemas. The final schema is the
                                                  composition of these component schemas. Required.
                                            ],
                                            "schemaVersion": "0.1"  #
                                              Optional. Default value is "0.1". The dyff schema
                                              version. "0.1"
                                        },
                                        "jsonSchema": {}  # Optional. The
                                          schema in JSON Schema format.
                                    },
                                    "viewOf": "str",  # ID of the resource that
                                      this is a view of. Required.
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",  # Name of a
                                              schema adapter available on the platform. Required.
                                            "configuration": {}  #
                                              Optional. Configuration for the schema adapter. Must be
                                              encodable as JSON.
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",  # An enumeration. Required. Known
                                  values are: "bentoml_service_openllm", "huggingface", "mock",
                                  "standalone", and "vllm".
                                "resources": {
                                    "storage": "str",  # Amount of storage
                                      required for packaged model, in k8s Quantity notation. Required.
                                    "memory": "str"  # Optional. Amount of memory
                                      required to run the model on CPU, in k8s Quantity notation.
                                },
                                "accelerator": {
                                    "kind": "str",  # The kind of accelerator;
                                      available kinds are {{GPU}}. Required.
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"  # Acceptable GPU
                                              hardware types. Required.
                                        ],
                                        "count": 1,  # Optional. Default
                                          value is 1. Number of GPUs required.
                                        "memory": "str"  # Optional.
                                          [DEPRECATED] Amount of GPU memory required, in k8s Quantity
                                          notation.
                                    }
                                },
                                "args": [
                                    "str"  # Optional. Command line arguments to
                                      forward to the runner.
                                ],
                                "image": {
                                    "digest": "str",  # The digest of the image.
                                      The image is always pulled by digest, even if 'tag' is specified.
                                      Required.
                                    "host": "str",  # The host of the container
                                      image registry. Required.
                                    "name": "str",  # The name of the image.
                                      Required.
                                    "tag": "str"  # Optional. The tag of the
                                      image. Although the image is always pulled by digest, including
                                      the tag is strongly recommended as it is often the main source of
                                      versioning information.
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        },
                        "annotations": [
                            {
                                "key": "str",  # The annotation key. A DNS label with
                                  an optional DNS domain prefix. For example: 'my-key',
                                  'your.com/key_0'. Names prefixed with 'dyff.io/',
                                  'subdomain.dyff.io/', etc. are reserved.  See
                                  https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                                  for detailed naming rules. Required.
                                "value": "str"  # The annotation value. An arbitrary
                                  string. Required.
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation
                          time (assigned by system).
                        "expires": "2020-02-20 00:00:00",  # Optional. Expiration time for
                          the session. Use of this field is recommended to avoid accidental compute
                          costs.
                        "kind": "InferenceSession",  # Optional. Default value is
                          "InferenceSession". Kind. "InferenceSession"
                        "labels": {
                            "str": "str"  # Optional. A set of key-value labels for the
                              resource. Used to specify identifying attributes of resources that are
                              meaningful to users but do not imply semantics in the dyff system.  The
                              keys are DNS labels with an optional DNS domain prefix. For example:
                              'my-key', 'your.com/key_0'. Keys prefixed with 'dyff.io/',
                              'subdomain.dyff.io/', etc. are reserved.  The label values are
                              alphanumeric characters separated by '.', '-', or '_'.  We follow the
                              kubernetes label conventions closely. See:
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                        },
                        "reason": "str",  # Optional. Reason for current status (assigned by
                          system).
                        "replicas": 1,  # Optional. Default value is 1. Number of model
                          replicas.
                        "schemaVersion": "0.1",  # Optional. Default value is "0.1". The
                          schema version. "0.1"
                        "status": "str",  # Optional. Top-level resource status (assigned by
                          system).
                        "useSpotPods": True  # Optional. Default value is True. Use 'spot
                          pods' for cheaper computation.
                    },
                    "token": "str"  # Token. Required.
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_inferencesessions_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get(self, session_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get an InferenceSession by its key.

        Get an InferenceSession by its key.

        Raises a 404 error if no entity exists with that key.

        :param session_id: Required.
        :type session_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "inferenceService": {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "interface": {
                            "endpoint": "str",  # HTTP endpoint for inference. Required.
                            "outputSchema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "inputPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ],
                            "outputPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        },
                        "name": "str",  # The name of the service. Required.
                        "builder": {
                            "kind": "str",  # Kind. Required.
                            "args": [
                                "str"  # Optional. Args.
                            ]
                        },
                        "model": {
                            "account": "str",  # Account that owns the entity. Required.
                            "artifact": {
                                "kind": "str",  # How the model data is represented.
                                  Required. "HuggingFaceCache"
                                "huggingFaceCache": {
                                    "repoID": "str",  # Name of the model in the
                                      HuggingFace cache. Required.
                                    "revision": "str"  # Model revision.
                                      Required.
                                }
                            },
                            "id": "str",  # Unique identifier of the entity. Required.
                            "name": "str",  # The name of the Model. Required.
                            "storage": {
                                "medium": "str"  # Storage medium. Required. Known
                                  values are: "ObjectStorage" and "PersistentVolume".
                            }
                        },
                        "outputViews": [
                            {
                                "id": "str",  # Unique ID of the DataView. Required.
                                "schema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "viewOf": "str",  # ID of the resource that this is a
                                  view of. Required.
                                "adapterPipeline": [
                                    {
                                        "kind": "str",  # Name of a schema
                                          adapter available on the platform. Required.
                                        "configuration": {}  # Optional.
                                          Configuration for the schema adapter. Must be encodable as
                                          JSON.
                                    }
                                ]
                            }
                        ],
                        "runner": {
                            "kind": "str",  # An enumeration. Required. Known values are:
                              "bentoml_service_openllm", "huggingface", "mock", "standalone", and
                              "vllm".
                            "resources": {
                                "storage": "str",  # Amount of storage required for
                                  packaged model, in k8s Quantity notation. Required.
                                "memory": "str"  # Optional. Amount of memory
                                  required to run the model on CPU, in k8s Quantity notation.
                            },
                            "accelerator": {
                                "kind": "str",  # The kind of accelerator; available
                                  kinds are {{GPU}}. Required.
                                "gpu": {
                                    "hardwareTypes": [
                                        "str"  # Acceptable GPU hardware
                                          types. Required.
                                    ],
                                    "count": 1,  # Optional. Default value is 1.
                                      Number of GPUs required.
                                    "memory": "str"  # Optional. [DEPRECATED]
                                      Amount of GPU memory required, in k8s Quantity notation.
                                }
                            },
                            "args": [
                                "str"  # Optional. Command line arguments to forward
                                  to the runner.
                            ],
                            "image": {
                                "digest": "str",  # The digest of the image. The
                                  image is always pulled by digest, even if 'tag' is specified.
                                  Required.
                                "host": "str",  # The host of the container image
                                  registry. Required.
                                "name": "str",  # The name of the image. Required.
                                "tag": "str"  # Optional. The tag of the image.
                                  Although the image is always pulled by digest, including the tag is
                                  strongly recommended as it is often the main source of versioning
                                  information.
                            }
                        }
                    },
                    "accelerator": {
                        "kind": "str",  # The kind of accelerator; available kinds are
                          {{GPU}}. Required.
                        "gpu": {
                            "hardwareTypes": [
                                "str"  # Acceptable GPU hardware types. Required.
                            ],
                            "count": 1,  # Optional. Default value is 1. Number of GPUs
                              required.
                            "memory": "str"  # Optional. [DEPRECATED] Amount of GPU
                              memory required, in k8s Quantity notation.
                        }
                    },
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "expires": "2020-02-20 00:00:00",  # Optional. Expiration time for the
                      session. Use of this field is recommended to avoid accidental compute costs.
                    "kind": "InferenceSession",  # Optional. Default value is "InferenceSession".
                      Kind. "InferenceSession"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "replicas": 1,  # Optional. Default value is 1. Number of model replicas.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str",  # Optional. Top-level resource status (assigned by system).
                    "useSpotPods": True  # Optional. Default value is True. Use 'spot pods' for
                      cheaper computation.
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_inferencesessions_get_request(
            session_id=session_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete(self, session_id: str, **kwargs: Any) -> JSON:
        """Mark an InferenceSession for deletion.

        Mark an InferenceSession for deletion.

        :param session_id: Required.
        :type session_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_inferencesessions_delete_request(
            session_id=session_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def terminate(self, session_id: str, **kwargs: Any) -> JSON:
        """Terminate an InferenceSession.

        Terminate an InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_inferencesessions_terminate_request(
            session_id=session_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def infer(
        self, session_id: str, inference_endpoint: str, **kwargs: Any
    ) -> Union[Any, JSON]:
        """Create an InferenceSession.

        Create an InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param inference_endpoint: Required.
        :type inference_endpoint: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        _request = build_inferencesessions_infer_request(
            session_id=session_id,
            inference_endpoint=inference_endpoint,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore

    @overload
    async def token(
        self,
        session_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[str, JSON]:
        # pylint: disable=line-too-long
        """Get an access token for an existing InferenceSession.

        Get an access token for an existing InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: str or JSON object
        :rtype: str or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "expires": "2020-02-20 00:00:00",  # Optional. Expiration time of the token.
                      Must be <= expiration time of session. Default: expiration time of session.
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def token(
        self,
        session_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[str, JSON]:
        """Get an access token for an existing InferenceSession.

        Get an access token for an existing InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: str or JSON object
        :rtype: str or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def token(
        self, session_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Union[str, JSON]:
        # pylint: disable=line-too-long
        """Get an access token for an existing InferenceSession.

        Get an access token for an existing InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: str or JSON object
        :rtype: str or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "expires": "2020-02-20 00:00:00",  # Optional. Expiration time of the token.
                      Must be <= expiration time of session. Default: expiration time of session.
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[str, JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_inferencesessions_token_request(
            session_id=session_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[str, JSON], deserialized), {})  # type: ignore

        return cast(Union[str, JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def ready(self, session_id: str, **kwargs: Any) -> Union[Any, JSON]:
        """Perform a readiness probe on the session.

        Check if an InferenceSession is ready. Returns status 200 if the session
        is ready. Raises a 503 (ServiceUnavailable) error if the session is not
        ready.

        Raises a 404 error if no session exists with the provided ID. Note
        that this may happen temporarily for session that were created
        recently, as it takes time for status information to propagate
        through the platform.

        :param session_id: Required.
        :type session_id: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        _request = build_inferencesessions_ready_request(
            session_id=session_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore


class MeasurementsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.aio.DyffV0API`'s
        :attr:`measurements` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    async def label(
        self,
        measurement_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Measurement.

        Update labels for an existing Measurement.

        :param measurement_id: Required.
        :type measurement_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def label(
        self,
        measurement_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        """Update labels for an existing Measurement.

        Update labels for an existing Measurement.

        :param measurement_id: Required.
        :type measurement_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def label(
        self, measurement_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Measurement.

        Update labels for an existing Measurement.

        :param measurement_id: Required.
        :type measurement_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_measurements_label_request(
            measurement_id=measurement_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        method: Optional[str] = None,
        method_name: Optional[str] = None,
        dataset: Optional[str] = None,
        evaluation: Optional[str] = None,
        inference_service: Optional[str] = None,
        model: Optional[str] = None,
        inputs: Optional[str] = None,
        **kwargs: Any,
    ) -> Union[List[JSON], JSON]:
        # pylint: disable=line-too-long
        """Get all Measurements matching a query.

        Get all Measurements matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword method: Default value is None.
        :paramtype method: str
        :keyword method_name: Default value is None.
        :paramtype method_name: str
        :keyword dataset: Default value is None.
        :paramtype dataset: str
        :keyword evaluation: Default value is None.
        :paramtype evaluation: str
        :keyword inference_service: Default value is None.
        :paramtype inference_service: str
        :keyword model: Default value is None.
        :paramtype model: str
        :keyword inputs: Default value is None.
        :paramtype inputs: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "level": "str",  # Measurement level. Required. Known values are:
                          "Dataset" and "Instance".
                        "method": {
                            "account": "str",  # Account that owns the entity. Required.
                            "id": "str",  # Unique identifier of the entity. Required.
                            "implementation": {
                                "kind": "str",  # The kind of implementation.
                                  Required.
                                "jupyterNotebook": {
                                    "notebookModule": "str",  # ID of the Module
                                      that contains the notebook file. This does *not* add the Module
                                      as a dependency; you must do that separately. Required.
                                    "notebookPath": "str"  # Path to the notebook
                                      file relative to the Module root directory. Required.
                                },
                                "pythonFunction": {
                                    "fullyQualifiedName": "str"  # The
                                      fully-qualified name of the Python function to call. Required.
                                },
                                "pythonRubric": {
                                    "fullyQualifiedName": "str"  # The
                                      fully-qualified name of the Python Rubric to run. Required.
                                }
                            },
                            "name": "str",  # Descriptive name of the Method. Required.
                            "output": {
                                "kind": "str",  # The kind of output artifact.
                                  Required. Known values are: "Measurement" and "SafetyCase".
                                "measurement": {
                                    "level": "str",  # Measurement level.
                                      Required. Known values are: "Dataset" and "Instance".
                                    "name": "str",  # Descriptive name of the
                                      Measurement. Required.
                                    "schema": {
                                        "arrowSchema": "str",  # The schema
                                          in Arrow format, encoded with
                                          dyff.schema.arrow.encode_schema(). This is required, but can
                                          be populated from a DyffDataSchema. Required.
                                        "dyffSchema": {
                                            "components": [
                                                "str"  # A list of
                                                  named dyff data schemas. The final schema is the
                                                  composition of these component schemas. Required.
                                            ],
                                            "schemaVersion": "0.1"  #
                                              Optional. Default value is "0.1". The dyff schema
                                              version. "0.1"
                                        },
                                        "jsonSchema": {}  # Optional. The
                                          schema in JSON Schema format.
                                    },
                                    "description": "str"  # Optional. Long-form
                                      description, interpreted as Markdown.
                                },
                                "safetyCase": {
                                    "name": "str",  # Descriptive name of the
                                      SafetyCase. Required.
                                    "description": "str"  # Optional. Long-form
                                      description, interpreted as Markdown.
                                }
                            },
                            "scope": "str",  # The scope of the Method. The Method
                              produces outputs that are specific to one entity of the type specified in
                              the .scope field. Required. Known values are: "InferenceService" and
                              "Evaluation".
                            "description": "str",  # Optional. Long-form description,
                              interpreted as Markdown.
                            "inputs": [
                                {
                                    "keyword": "str",  # The input is referred to
                                      by 'keyword' in the context of the method implementation.
                                      Required.
                                    "kind": "str",  # The kind of input artifact.
                                      Required. Known values are: "Dataset", "Evaluation",
                                      "Measurement", and "Report".
                                    "description": "str"  # Optional. Long-form
                                      description, interpreted as Markdown.
                                }
                            ],
                            "modules": [
                                "str"  # Optional. Modules to load into the analysis
                                  environment.
                            ],
                            "parameters": [
                                {
                                    "keyword": "str",  # The parameter is
                                      referred to by 'keyword' in the context of the method
                                      implementation. Required.
                                    "description": "str"  # Optional. Long-form
                                      description, interpreted as Markdown.
                                }
                            ]
                        },
                        "name": "str",  # Descriptive name of the Measurement. Required.
                        "schema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "annotations": [
                            {
                                "key": "str",  # The annotation key. A DNS label with
                                  an optional DNS domain prefix. For example: 'my-key',
                                  'your.com/key_0'. Names prefixed with 'dyff.io/',
                                  'subdomain.dyff.io/', etc. are reserved.  See
                                  https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                                  for detailed naming rules. Required.
                                "value": "str"  # The annotation value. An arbitrary
                                  string. Required.
                            }
                        ],
                        "arguments": [
                            {
                                "keyword": "str",  # The 'keyword' of the
                                  corresponding ModelParameter. Required.
                                "value": "str"  # The value of of the argument.
                                  Always a string; implementations are responsible for parsing.
                                  Required.
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation
                          time (assigned by system).
                        "description": "str",  # Optional. Long-form description, interpreted
                          as Markdown.
                        "inputs": [
                            {
                                "entity": "str",  # The ID of the entity whose data
                                  should be made available as 'keyword'. Required.
                                "keyword": "str"  # The 'keyword' specified for this
                                  input in the MethodSpec. Required.
                            }
                        ],
                        "kind": "Measurement",  # Optional. Default value is "Measurement".
                          Kind. "Measurement"
                        "labels": {
                            "str": "str"  # Optional. A set of key-value labels for the
                              resource. Used to specify identifying attributes of resources that are
                              meaningful to users but do not imply semantics in the dyff system.  The
                              keys are DNS labels with an optional DNS domain prefix. For example:
                              'my-key', 'your.com/key_0'. Keys prefixed with 'dyff.io/',
                              'subdomain.dyff.io/', etc. are reserved.  The label values are
                              alphanumeric characters separated by '.', '-', or '_'.  We follow the
                              kubernetes label conventions closely. See:
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                        },
                        "reason": "str",  # Optional. Reason for current status (assigned by
                          system).
                        "schemaVersion": "0.1",  # Optional. Default value is "0.1". The
                          schema version. "0.1"
                        "scope": {
                            "dataset": "str",  # Optional. The Dataset to which the
                              analysis applies.
                            "evaluation": "str",  # Optional. The Evaluation to which the
                              analysis applies.
                            "inferenceService": "str",  # Optional. The InferenceService
                              to which the analysis applies.
                            "model": "str"  # Optional. The Model to which the analysis
                              applies.
                        },
                        "status": "str"  # Optional. Top-level resource status (assigned by
                          system).
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_measurements_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            method=method,
            method_name=method_name,
            dataset=dataset,
            evaluation=evaluation,
            inference_service=inference_service,
            model=model,
            inputs=inputs,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a Measurement.

        Create a Measurement.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "method": "str",  # Method ID. Required.
                    "arguments": [
                        {
                            "keyword": "str",  # The 'keyword' of the corresponding
                              ModelParameter. Required.
                            "value": "str"  # The value of of the argument. Always a
                              string; implementations are responsible for parsing. Required.
                        }
                    ],
                    "inputs": [
                        {
                            "entity": "str",  # The ID of the entity whose data should be
                              made available as 'keyword'. Required.
                            "keyword": "str"  # The 'keyword' specified for this input in
                              the MethodSpec. Required.
                        }
                    ],
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "scope": {
                        "dataset": "str",  # Optional. The Dataset to which the analysis
                          applies.
                        "evaluation": "str",  # Optional. The Evaluation to which the
                          analysis applies.
                        "inferenceService": "str",  # Optional. The InferenceService to which
                          the analysis applies.
                        "model": "str"  # Optional. The Model to which the analysis applies.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "level": "str",  # Measurement level. Required. Known values are: "Dataset"
                      and "Instance".
                    "method": {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "implementation": {
                            "kind": "str",  # The kind of implementation. Required.
                            "jupyterNotebook": {
                                "notebookModule": "str",  # ID of the Module that
                                  contains the notebook file. This does *not* add the Module as a
                                  dependency; you must do that separately. Required.
                                "notebookPath": "str"  # Path to the notebook file
                                  relative to the Module root directory. Required.
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python function to call. Required.
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python Rubric to run. Required.
                            }
                        },
                        "name": "str",  # Descriptive name of the Method. Required.
                        "output": {
                            "kind": "str",  # The kind of output artifact. Required.
                              Known values are: "Measurement" and "SafetyCase".
                            "measurement": {
                                "level": "str",  # Measurement level. Required. Known
                                  values are: "Dataset" and "Instance".
                                "name": "str",  # Descriptive name of the
                                  Measurement. Required.
                                "schema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            },
                            "safetyCase": {
                                "name": "str",  # Descriptive name of the SafetyCase.
                                  Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        },
                        "scope": "str",  # The scope of the Method. The Method produces
                          outputs that are specific to one entity of the type specified in the .scope
                          field. Required. Known values are: "InferenceService" and "Evaluation".
                        "description": "str",  # Optional. Long-form description, interpreted
                          as Markdown.
                        "inputs": [
                            {
                                "keyword": "str",  # The input is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "kind": "str",  # The kind of input artifact.
                                  Required. Known values are: "Dataset", "Evaluation", "Measurement",
                                  and "Report".
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ],
                        "modules": [
                            "str"  # Optional. Modules to load into the analysis
                              environment.
                        ],
                        "parameters": [
                            {
                                "keyword": "str",  # The parameter is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ]
                    },
                    "name": "str",  # Descriptive name of the Measurement. Required.
                    "schema": {
                        "arrowSchema": "str",  # The schema in Arrow format, encoded with
                          dyff.schema.arrow.encode_schema(). This is required, but can be populated
                          from a DyffDataSchema. Required.
                        "dyffSchema": {
                            "components": [
                                "str"  # A list of named dyff data schemas. The final
                                  schema is the composition of these component schemas. Required.
                            ],
                            "schemaVersion": "0.1"  # Optional. Default value is "0.1".
                              The dyff schema version. "0.1"
                        },
                        "jsonSchema": {}  # Optional. The schema in JSON Schema format.
                    },
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",  # The 'keyword' of the corresponding
                              ModelParameter. Required.
                            "value": "str"  # The value of of the argument. Always a
                              string; implementations are responsible for parsing. Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "entity": "str",  # The ID of the entity whose data should be
                              made available as 'keyword'. Required.
                            "keyword": "str"  # The 'keyword' specified for this input in
                              the MethodSpec. Required.
                        }
                    ],
                    "kind": "Measurement",  # Optional. Default value is "Measurement". Kind.
                      "Measurement"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "scope": {
                        "dataset": "str",  # Optional. The Dataset to which the analysis
                          applies.
                        "evaluation": "str",  # Optional. The Evaluation to which the
                          analysis applies.
                        "inferenceService": "str",  # Optional. The InferenceService to which
                          the analysis applies.
                        "model": "str"  # Optional. The Model to which the analysis applies.
                    },
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a Measurement.

        Create a Measurement.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "level": "str",  # Measurement level. Required. Known values are: "Dataset"
                      and "Instance".
                    "method": {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "implementation": {
                            "kind": "str",  # The kind of implementation. Required.
                            "jupyterNotebook": {
                                "notebookModule": "str",  # ID of the Module that
                                  contains the notebook file. This does *not* add the Module as a
                                  dependency; you must do that separately. Required.
                                "notebookPath": "str"  # Path to the notebook file
                                  relative to the Module root directory. Required.
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python function to call. Required.
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python Rubric to run. Required.
                            }
                        },
                        "name": "str",  # Descriptive name of the Method. Required.
                        "output": {
                            "kind": "str",  # The kind of output artifact. Required.
                              Known values are: "Measurement" and "SafetyCase".
                            "measurement": {
                                "level": "str",  # Measurement level. Required. Known
                                  values are: "Dataset" and "Instance".
                                "name": "str",  # Descriptive name of the
                                  Measurement. Required.
                                "schema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            },
                            "safetyCase": {
                                "name": "str",  # Descriptive name of the SafetyCase.
                                  Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        },
                        "scope": "str",  # The scope of the Method. The Method produces
                          outputs that are specific to one entity of the type specified in the .scope
                          field. Required. Known values are: "InferenceService" and "Evaluation".
                        "description": "str",  # Optional. Long-form description, interpreted
                          as Markdown.
                        "inputs": [
                            {
                                "keyword": "str",  # The input is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "kind": "str",  # The kind of input artifact.
                                  Required. Known values are: "Dataset", "Evaluation", "Measurement",
                                  and "Report".
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ],
                        "modules": [
                            "str"  # Optional. Modules to load into the analysis
                              environment.
                        ],
                        "parameters": [
                            {
                                "keyword": "str",  # The parameter is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ]
                    },
                    "name": "str",  # Descriptive name of the Measurement. Required.
                    "schema": {
                        "arrowSchema": "str",  # The schema in Arrow format, encoded with
                          dyff.schema.arrow.encode_schema(). This is required, but can be populated
                          from a DyffDataSchema. Required.
                        "dyffSchema": {
                            "components": [
                                "str"  # A list of named dyff data schemas. The final
                                  schema is the composition of these component schemas. Required.
                            ],
                            "schemaVersion": "0.1"  # Optional. Default value is "0.1".
                              The dyff schema version. "0.1"
                        },
                        "jsonSchema": {}  # Optional. The schema in JSON Schema format.
                    },
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",  # The 'keyword' of the corresponding
                              ModelParameter. Required.
                            "value": "str"  # The value of of the argument. Always a
                              string; implementations are responsible for parsing. Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "entity": "str",  # The ID of the entity whose data should be
                              made available as 'keyword'. Required.
                            "keyword": "str"  # The 'keyword' specified for this input in
                              the MethodSpec. Required.
                        }
                    ],
                    "kind": "Measurement",  # Optional. Default value is "Measurement". Kind.
                      "Measurement"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "scope": {
                        "dataset": "str",  # Optional. The Dataset to which the analysis
                          applies.
                        "evaluation": "str",  # Optional. The Evaluation to which the
                          analysis applies.
                        "inferenceService": "str",  # Optional. The InferenceService to which
                          the analysis applies.
                        "model": "str"  # Optional. The Model to which the analysis applies.
                    },
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create a Measurement.

        Create a Measurement.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "method": "str",  # Method ID. Required.
                    "arguments": [
                        {
                            "keyword": "str",  # The 'keyword' of the corresponding
                              ModelParameter. Required.
                            "value": "str"  # The value of of the argument. Always a
                              string; implementations are responsible for parsing. Required.
                        }
                    ],
                    "inputs": [
                        {
                            "entity": "str",  # The ID of the entity whose data should be
                              made available as 'keyword'. Required.
                            "keyword": "str"  # The 'keyword' specified for this input in
                              the MethodSpec. Required.
                        }
                    ],
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "scope": {
                        "dataset": "str",  # Optional. The Dataset to which the analysis
                          applies.
                        "evaluation": "str",  # Optional. The Evaluation to which the
                          analysis applies.
                        "inferenceService": "str",  # Optional. The InferenceService to which
                          the analysis applies.
                        "model": "str"  # Optional. The Model to which the analysis applies.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "level": "str",  # Measurement level. Required. Known values are: "Dataset"
                      and "Instance".
                    "method": {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "implementation": {
                            "kind": "str",  # The kind of implementation. Required.
                            "jupyterNotebook": {
                                "notebookModule": "str",  # ID of the Module that
                                  contains the notebook file. This does *not* add the Module as a
                                  dependency; you must do that separately. Required.
                                "notebookPath": "str"  # Path to the notebook file
                                  relative to the Module root directory. Required.
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python function to call. Required.
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python Rubric to run. Required.
                            }
                        },
                        "name": "str",  # Descriptive name of the Method. Required.
                        "output": {
                            "kind": "str",  # The kind of output artifact. Required.
                              Known values are: "Measurement" and "SafetyCase".
                            "measurement": {
                                "level": "str",  # Measurement level. Required. Known
                                  values are: "Dataset" and "Instance".
                                "name": "str",  # Descriptive name of the
                                  Measurement. Required.
                                "schema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            },
                            "safetyCase": {
                                "name": "str",  # Descriptive name of the SafetyCase.
                                  Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        },
                        "scope": "str",  # The scope of the Method. The Method produces
                          outputs that are specific to one entity of the type specified in the .scope
                          field. Required. Known values are: "InferenceService" and "Evaluation".
                        "description": "str",  # Optional. Long-form description, interpreted
                          as Markdown.
                        "inputs": [
                            {
                                "keyword": "str",  # The input is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "kind": "str",  # The kind of input artifact.
                                  Required. Known values are: "Dataset", "Evaluation", "Measurement",
                                  and "Report".
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ],
                        "modules": [
                            "str"  # Optional. Modules to load into the analysis
                              environment.
                        ],
                        "parameters": [
                            {
                                "keyword": "str",  # The parameter is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ]
                    },
                    "name": "str",  # Descriptive name of the Measurement. Required.
                    "schema": {
                        "arrowSchema": "str",  # The schema in Arrow format, encoded with
                          dyff.schema.arrow.encode_schema(). This is required, but can be populated
                          from a DyffDataSchema. Required.
                        "dyffSchema": {
                            "components": [
                                "str"  # A list of named dyff data schemas. The final
                                  schema is the composition of these component schemas. Required.
                            ],
                            "schemaVersion": "0.1"  # Optional. Default value is "0.1".
                              The dyff schema version. "0.1"
                        },
                        "jsonSchema": {}  # Optional. The schema in JSON Schema format.
                    },
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",  # The 'keyword' of the corresponding
                              ModelParameter. Required.
                            "value": "str"  # The value of of the argument. Always a
                              string; implementations are responsible for parsing. Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "entity": "str",  # The ID of the entity whose data should be
                              made available as 'keyword'. Required.
                            "keyword": "str"  # The 'keyword' specified for this input in
                              the MethodSpec. Required.
                        }
                    ],
                    "kind": "Measurement",  # Optional. Default value is "Measurement". Kind.
                      "Measurement"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "scope": {
                        "dataset": "str",  # Optional. The Dataset to which the analysis
                          applies.
                        "evaluation": "str",  # Optional. The Evaluation to which the
                          analysis applies.
                        "inferenceService": "str",  # Optional. The InferenceService to which
                          the analysis applies.
                        "model": "str"  # Optional. The Model to which the analysis applies.
                    },
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_measurements_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get(self, measurement_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get a Measurement by its key.

        Get a Measurement by its key.

        Raises a 404 error if no entity exists with that key.

        :param measurement_id: Required.
        :type measurement_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "level": "str",  # Measurement level. Required. Known values are: "Dataset"
                      and "Instance".
                    "method": {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "implementation": {
                            "kind": "str",  # The kind of implementation. Required.
                            "jupyterNotebook": {
                                "notebookModule": "str",  # ID of the Module that
                                  contains the notebook file. This does *not* add the Module as a
                                  dependency; you must do that separately. Required.
                                "notebookPath": "str"  # Path to the notebook file
                                  relative to the Module root directory. Required.
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python function to call. Required.
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python Rubric to run. Required.
                            }
                        },
                        "name": "str",  # Descriptive name of the Method. Required.
                        "output": {
                            "kind": "str",  # The kind of output artifact. Required.
                              Known values are: "Measurement" and "SafetyCase".
                            "measurement": {
                                "level": "str",  # Measurement level. Required. Known
                                  values are: "Dataset" and "Instance".
                                "name": "str",  # Descriptive name of the
                                  Measurement. Required.
                                "schema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            },
                            "safetyCase": {
                                "name": "str",  # Descriptive name of the SafetyCase.
                                  Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        },
                        "scope": "str",  # The scope of the Method. The Method produces
                          outputs that are specific to one entity of the type specified in the .scope
                          field. Required. Known values are: "InferenceService" and "Evaluation".
                        "description": "str",  # Optional. Long-form description, interpreted
                          as Markdown.
                        "inputs": [
                            {
                                "keyword": "str",  # The input is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "kind": "str",  # The kind of input artifact.
                                  Required. Known values are: "Dataset", "Evaluation", "Measurement",
                                  and "Report".
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ],
                        "modules": [
                            "str"  # Optional. Modules to load into the analysis
                              environment.
                        ],
                        "parameters": [
                            {
                                "keyword": "str",  # The parameter is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ]
                    },
                    "name": "str",  # Descriptive name of the Measurement. Required.
                    "schema": {
                        "arrowSchema": "str",  # The schema in Arrow format, encoded with
                          dyff.schema.arrow.encode_schema(). This is required, but can be populated
                          from a DyffDataSchema. Required.
                        "dyffSchema": {
                            "components": [
                                "str"  # A list of named dyff data schemas. The final
                                  schema is the composition of these component schemas. Required.
                            ],
                            "schemaVersion": "0.1"  # Optional. Default value is "0.1".
                              The dyff schema version. "0.1"
                        },
                        "jsonSchema": {}  # Optional. The schema in JSON Schema format.
                    },
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",  # The 'keyword' of the corresponding
                              ModelParameter. Required.
                            "value": "str"  # The value of of the argument. Always a
                              string; implementations are responsible for parsing. Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "entity": "str",  # The ID of the entity whose data should be
                              made available as 'keyword'. Required.
                            "keyword": "str"  # The 'keyword' specified for this input in
                              the MethodSpec. Required.
                        }
                    ],
                    "kind": "Measurement",  # Optional. Default value is "Measurement". Kind.
                      "Measurement"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "scope": {
                        "dataset": "str",  # Optional. The Dataset to which the analysis
                          applies.
                        "evaluation": "str",  # Optional. The Evaluation to which the
                          analysis applies.
                        "inferenceService": "str",  # Optional. The InferenceService to which
                          the analysis applies.
                        "model": "str"  # Optional. The Model to which the analysis applies.
                    },
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_measurements_get_request(
            measurement_id=measurement_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete(self, measurement_id: str, **kwargs: Any) -> JSON:
        """Mark a Measurement for deletion.

        Mark a Measurement for deletion.

        :param measurement_id: Required.
        :type measurement_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_measurements_delete_request(
            measurement_id=measurement_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def downlinks(
        self, measurement_id: str, **kwargs: Any
    ) -> Union[List[JSON], JSON]:
        """Get a list of signed GET URLs from which measurement artifacts can be
        downloaded.

        Get a list of signed GET URLs from which measurement artifacts can be downloaded.

        :param measurement_id: Required.
        :type measurement_id: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "artifact": {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        },
                        "signedURL": {
                            "method": "str",  # The HTTP method applicable to the URL.
                              Required.
                            "url": "str",  # The signed URL. Required.
                            "headers": {
                                "str": "str"  # Optional. Mandatory headers that must
                                  be passed with the request.
                            }
                        }
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_measurements_downlinks_request(
            measurement_id=measurement_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def logs(self, measurement_id: str, **kwargs: Any) -> JSON:
        """Get a signed GET URL from which the logs file for the measurement run can be
        downloaded.

        Get a signed GET URL from which the logs file for the measurement run can be downloaded.

        :param measurement_id: Required.
        :type measurement_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "artifact": {
                        "path": "str",  # The relative path of the artifact within the tree.
                          Required.
                        "digest": {
                            "md5": "str"  # Optional. md5 digest of artifact data.
                        },
                        "kind": "str"  # Optional. The kind of artifact.
                    },
                    "signedURL": {
                        "method": "str",  # The HTTP method applicable to the URL. Required.
                        "url": "str",  # The signed URL. Required.
                        "headers": {
                            "str": "str"  # Optional. Mandatory headers that must be
                              passed with the request.
                        }
                    }
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_measurements_logs_request(
            measurement_id=measurement_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class MethodsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.aio.DyffV0API`'s
        :attr:`methods` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    async def label(
        self,
        method_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Method.

        Update labels for an existing Method.

        :param method_id: Required.
        :type method_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def label(
        self,
        method_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        """Update labels for an existing Method.

        Update labels for an existing Method.

        :param method_id: Required.
        :type method_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def label(
        self, method_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Method.

        Update labels for an existing Method.

        :param method_id: Required.
        :type method_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_methods_label_request(
            method_id=method_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        name: Optional[str] = None,
        output_kind: Optional[str] = None,
        **kwargs: Any,
    ) -> Union[List[JSON], JSON]:
        # pylint: disable=line-too-long
        """Get all Methods matching a query.

        Get all Methods matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword output_kind: Default value is None.
        :paramtype output_kind: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "implementation": {
                            "kind": "str",  # The kind of implementation. Required.
                            "jupyterNotebook": {
                                "notebookModule": "str",  # ID of the Module that
                                  contains the notebook file. This does *not* add the Module as a
                                  dependency; you must do that separately. Required.
                                "notebookPath": "str"  # Path to the notebook file
                                  relative to the Module root directory. Required.
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python function to call. Required.
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python Rubric to run. Required.
                            }
                        },
                        "name": "str",  # Descriptive name of the Method. Required.
                        "output": {
                            "kind": "str",  # The kind of output artifact. Required.
                              Known values are: "Measurement" and "SafetyCase".
                            "measurement": {
                                "level": "str",  # Measurement level. Required. Known
                                  values are: "Dataset" and "Instance".
                                "name": "str",  # Descriptive name of the
                                  Measurement. Required.
                                "schema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            },
                            "safetyCase": {
                                "name": "str",  # Descriptive name of the SafetyCase.
                                  Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        },
                        "scope": "str",  # The scope of the Method. The Method produces
                          outputs that are specific to one entity of the type specified in the .scope
                          field. Required. Known values are: "InferenceService" and "Evaluation".
                        "annotations": [
                            {
                                "key": "str",  # The annotation key. A DNS label with
                                  an optional DNS domain prefix. For example: 'my-key',
                                  'your.com/key_0'. Names prefixed with 'dyff.io/',
                                  'subdomain.dyff.io/', etc. are reserved.  See
                                  https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                                  for detailed naming rules. Required.
                                "value": "str"  # The annotation value. An arbitrary
                                  string. Required.
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation
                          time (assigned by system).
                        "description": "str",  # Optional. Long-form description, interpreted
                          as Markdown.
                        "inputs": [
                            {
                                "keyword": "str",  # The input is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "kind": "str",  # The kind of input artifact.
                                  Required. Known values are: "Dataset", "Evaluation", "Measurement",
                                  and "Report".
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ],
                        "kind": "Method",  # Optional. Default value is "Method". Kind.
                          "Method"
                        "labels": {
                            "str": "str"  # Optional. A set of key-value labels for the
                              resource. Used to specify identifying attributes of resources that are
                              meaningful to users but do not imply semantics in the dyff system.  The
                              keys are DNS labels with an optional DNS domain prefix. For example:
                              'my-key', 'your.com/key_0'. Keys prefixed with 'dyff.io/',
                              'subdomain.dyff.io/', etc. are reserved.  The label values are
                              alphanumeric characters separated by '.', '-', or '_'.  We follow the
                              kubernetes label conventions closely. See:
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                        },
                        "modules": [
                            "str"  # Optional. Modules to load into the analysis
                              environment.
                        ],
                        "parameters": [
                            {
                                "keyword": "str",  # The parameter is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ],
                        "reason": "str",  # Optional. Reason for current status (assigned by
                          system).
                        "schemaVersion": "0.1",  # Optional. Default value is "0.1". The
                          schema version. "0.1"
                        "status": "str"  # Optional. Top-level resource status (assigned by
                          system).
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_methods_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            name=name,
            output_kind=output_kind,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a Method.

        Create a Method.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "implementation": {
                        "kind": "str",  # The kind of implementation. Required.
                        "jupyterNotebook": {
                            "notebookModule": "str",  # ID of the Module that contains
                              the notebook file. This does *not* add the Module as a dependency; you
                              must do that separately. Required.
                            "notebookPath": "str"  # Path to the notebook file relative
                              to the Module root directory. Required.
                        },
                        "pythonFunction": {
                            "fullyQualifiedName": "str"  # The fully-qualified name of
                              the Python function to call. Required.
                        },
                        "pythonRubric": {
                            "fullyQualifiedName": "str"  # The fully-qualified name of
                              the Python Rubric to run. Required.
                        }
                    },
                    "name": "str",  # Descriptive name of the Method. Required.
                    "output": {
                        "kind": "str",  # The kind of output artifact. Required. Known values
                          are: "Measurement" and "SafetyCase".
                        "measurement": {
                            "level": "str",  # Measurement level. Required. Known values
                              are: "Dataset" and "Instance".
                            "name": "str",  # Descriptive name of the Measurement.
                              Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        },
                        "safetyCase": {
                            "name": "str",  # Descriptive name of the SafetyCase.
                              Required.
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    },
                    "scope": "str",  # The scope of the Method. The Method produces outputs that
                      are specific to one entity of the type specified in the .scope field. Required.
                      Known values are: "InferenceService" and "Evaluation".
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "keyword": "str",  # The input is referred to by 'keyword' in
                              the context of the method implementation. Required.
                            "kind": "str",  # The kind of input artifact. Required. Known
                              values are: "Dataset", "Evaluation", "Measurement", and "Report".
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    ],
                    "modules": [
                        "str"  # Optional. Modules to load into the analysis environment.
                    ],
                    "parameters": [
                        {
                            "keyword": "str",  # The parameter is referred to by
                              'keyword' in the context of the method implementation. Required.
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    ],
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "implementation": {
                        "kind": "str",  # The kind of implementation. Required.
                        "jupyterNotebook": {
                            "notebookModule": "str",  # ID of the Module that contains
                              the notebook file. This does *not* add the Module as a dependency; you
                              must do that separately. Required.
                            "notebookPath": "str"  # Path to the notebook file relative
                              to the Module root directory. Required.
                        },
                        "pythonFunction": {
                            "fullyQualifiedName": "str"  # The fully-qualified name of
                              the Python function to call. Required.
                        },
                        "pythonRubric": {
                            "fullyQualifiedName": "str"  # The fully-qualified name of
                              the Python Rubric to run. Required.
                        }
                    },
                    "name": "str",  # Descriptive name of the Method. Required.
                    "output": {
                        "kind": "str",  # The kind of output artifact. Required. Known values
                          are: "Measurement" and "SafetyCase".
                        "measurement": {
                            "level": "str",  # Measurement level. Required. Known values
                              are: "Dataset" and "Instance".
                            "name": "str",  # Descriptive name of the Measurement.
                              Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        },
                        "safetyCase": {
                            "name": "str",  # Descriptive name of the SafetyCase.
                              Required.
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    },
                    "scope": "str",  # The scope of the Method. The Method produces outputs that
                      are specific to one entity of the type specified in the .scope field. Required.
                      Known values are: "InferenceService" and "Evaluation".
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "keyword": "str",  # The input is referred to by 'keyword' in
                              the context of the method implementation. Required.
                            "kind": "str",  # The kind of input artifact. Required. Known
                              values are: "Dataset", "Evaluation", "Measurement", and "Report".
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    ],
                    "kind": "Method",  # Optional. Default value is "Method". Kind. "Method"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "modules": [
                        "str"  # Optional. Modules to load into the analysis environment.
                    ],
                    "parameters": [
                        {
                            "keyword": "str",  # The parameter is referred to by
                              'keyword' in the context of the method implementation. Required.
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    ],
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a Method.

        Create a Method.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "implementation": {
                        "kind": "str",  # The kind of implementation. Required.
                        "jupyterNotebook": {
                            "notebookModule": "str",  # ID of the Module that contains
                              the notebook file. This does *not* add the Module as a dependency; you
                              must do that separately. Required.
                            "notebookPath": "str"  # Path to the notebook file relative
                              to the Module root directory. Required.
                        },
                        "pythonFunction": {
                            "fullyQualifiedName": "str"  # The fully-qualified name of
                              the Python function to call. Required.
                        },
                        "pythonRubric": {
                            "fullyQualifiedName": "str"  # The fully-qualified name of
                              the Python Rubric to run. Required.
                        }
                    },
                    "name": "str",  # Descriptive name of the Method. Required.
                    "output": {
                        "kind": "str",  # The kind of output artifact. Required. Known values
                          are: "Measurement" and "SafetyCase".
                        "measurement": {
                            "level": "str",  # Measurement level. Required. Known values
                              are: "Dataset" and "Instance".
                            "name": "str",  # Descriptive name of the Measurement.
                              Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        },
                        "safetyCase": {
                            "name": "str",  # Descriptive name of the SafetyCase.
                              Required.
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    },
                    "scope": "str",  # The scope of the Method. The Method produces outputs that
                      are specific to one entity of the type specified in the .scope field. Required.
                      Known values are: "InferenceService" and "Evaluation".
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "keyword": "str",  # The input is referred to by 'keyword' in
                              the context of the method implementation. Required.
                            "kind": "str",  # The kind of input artifact. Required. Known
                              values are: "Dataset", "Evaluation", "Measurement", and "Report".
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    ],
                    "kind": "Method",  # Optional. Default value is "Method". Kind. "Method"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "modules": [
                        "str"  # Optional. Modules to load into the analysis environment.
                    ],
                    "parameters": [
                        {
                            "keyword": "str",  # The parameter is referred to by
                              'keyword' in the context of the method implementation. Required.
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    ],
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create a Method.

        Create a Method.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "implementation": {
                        "kind": "str",  # The kind of implementation. Required.
                        "jupyterNotebook": {
                            "notebookModule": "str",  # ID of the Module that contains
                              the notebook file. This does *not* add the Module as a dependency; you
                              must do that separately. Required.
                            "notebookPath": "str"  # Path to the notebook file relative
                              to the Module root directory. Required.
                        },
                        "pythonFunction": {
                            "fullyQualifiedName": "str"  # The fully-qualified name of
                              the Python function to call. Required.
                        },
                        "pythonRubric": {
                            "fullyQualifiedName": "str"  # The fully-qualified name of
                              the Python Rubric to run. Required.
                        }
                    },
                    "name": "str",  # Descriptive name of the Method. Required.
                    "output": {
                        "kind": "str",  # The kind of output artifact. Required. Known values
                          are: "Measurement" and "SafetyCase".
                        "measurement": {
                            "level": "str",  # Measurement level. Required. Known values
                              are: "Dataset" and "Instance".
                            "name": "str",  # Descriptive name of the Measurement.
                              Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        },
                        "safetyCase": {
                            "name": "str",  # Descriptive name of the SafetyCase.
                              Required.
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    },
                    "scope": "str",  # The scope of the Method. The Method produces outputs that
                      are specific to one entity of the type specified in the .scope field. Required.
                      Known values are: "InferenceService" and "Evaluation".
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "keyword": "str",  # The input is referred to by 'keyword' in
                              the context of the method implementation. Required.
                            "kind": "str",  # The kind of input artifact. Required. Known
                              values are: "Dataset", "Evaluation", "Measurement", and "Report".
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    ],
                    "modules": [
                        "str"  # Optional. Modules to load into the analysis environment.
                    ],
                    "parameters": [
                        {
                            "keyword": "str",  # The parameter is referred to by
                              'keyword' in the context of the method implementation. Required.
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    ],
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "implementation": {
                        "kind": "str",  # The kind of implementation. Required.
                        "jupyterNotebook": {
                            "notebookModule": "str",  # ID of the Module that contains
                              the notebook file. This does *not* add the Module as a dependency; you
                              must do that separately. Required.
                            "notebookPath": "str"  # Path to the notebook file relative
                              to the Module root directory. Required.
                        },
                        "pythonFunction": {
                            "fullyQualifiedName": "str"  # The fully-qualified name of
                              the Python function to call. Required.
                        },
                        "pythonRubric": {
                            "fullyQualifiedName": "str"  # The fully-qualified name of
                              the Python Rubric to run. Required.
                        }
                    },
                    "name": "str",  # Descriptive name of the Method. Required.
                    "output": {
                        "kind": "str",  # The kind of output artifact. Required. Known values
                          are: "Measurement" and "SafetyCase".
                        "measurement": {
                            "level": "str",  # Measurement level. Required. Known values
                              are: "Dataset" and "Instance".
                            "name": "str",  # Descriptive name of the Measurement.
                              Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        },
                        "safetyCase": {
                            "name": "str",  # Descriptive name of the SafetyCase.
                              Required.
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    },
                    "scope": "str",  # The scope of the Method. The Method produces outputs that
                      are specific to one entity of the type specified in the .scope field. Required.
                      Known values are: "InferenceService" and "Evaluation".
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "keyword": "str",  # The input is referred to by 'keyword' in
                              the context of the method implementation. Required.
                            "kind": "str",  # The kind of input artifact. Required. Known
                              values are: "Dataset", "Evaluation", "Measurement", and "Report".
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    ],
                    "kind": "Method",  # Optional. Default value is "Method". Kind. "Method"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "modules": [
                        "str"  # Optional. Modules to load into the analysis environment.
                    ],
                    "parameters": [
                        {
                            "keyword": "str",  # The parameter is referred to by
                              'keyword' in the context of the method implementation. Required.
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    ],
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_methods_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get(self, method_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get a Method by its key.

        Get a Method by its key.

        Raises a 404 error if no entity exists with that key.

        :param method_id: Required.
        :type method_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "implementation": {
                        "kind": "str",  # The kind of implementation. Required.
                        "jupyterNotebook": {
                            "notebookModule": "str",  # ID of the Module that contains
                              the notebook file. This does *not* add the Module as a dependency; you
                              must do that separately. Required.
                            "notebookPath": "str"  # Path to the notebook file relative
                              to the Module root directory. Required.
                        },
                        "pythonFunction": {
                            "fullyQualifiedName": "str"  # The fully-qualified name of
                              the Python function to call. Required.
                        },
                        "pythonRubric": {
                            "fullyQualifiedName": "str"  # The fully-qualified name of
                              the Python Rubric to run. Required.
                        }
                    },
                    "name": "str",  # Descriptive name of the Method. Required.
                    "output": {
                        "kind": "str",  # The kind of output artifact. Required. Known values
                          are: "Measurement" and "SafetyCase".
                        "measurement": {
                            "level": "str",  # Measurement level. Required. Known values
                              are: "Dataset" and "Instance".
                            "name": "str",  # Descriptive name of the Measurement.
                              Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        },
                        "safetyCase": {
                            "name": "str",  # Descriptive name of the SafetyCase.
                              Required.
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    },
                    "scope": "str",  # The scope of the Method. The Method produces outputs that
                      are specific to one entity of the type specified in the .scope field. Required.
                      Known values are: "InferenceService" and "Evaluation".
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "keyword": "str",  # The input is referred to by 'keyword' in
                              the context of the method implementation. Required.
                            "kind": "str",  # The kind of input artifact. Required. Known
                              values are: "Dataset", "Evaluation", "Measurement", and "Report".
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    ],
                    "kind": "Method",  # Optional. Default value is "Method". Kind. "Method"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "modules": [
                        "str"  # Optional. Modules to load into the analysis environment.
                    ],
                    "parameters": [
                        {
                            "keyword": "str",  # The parameter is referred to by
                              'keyword' in the context of the method implementation. Required.
                            "description": "str"  # Optional. Long-form description,
                              interpreted as Markdown.
                        }
                    ],
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_methods_get_request(
            method_id=method_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete(self, method_id: str, **kwargs: Any) -> JSON:
        """Mark a Method for deletion.

        Mark a Method for deletion.

        :param method_id: Required.
        :type method_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_methods_delete_request(
            method_id=method_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def documentation(self, method_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get the documentation associated with a Method.

        Get the documentation associated with a Method.

        Raises a 404 error if no entity exists with that key.

        :param method_id: Required.
        :type method_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_methods_documentation_request(
            method_id=method_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def edit_documentation(
        self,
        method_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with a Method.

        Edit the documentation associated with a Method.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param method_id: Required.
        :type method_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def edit_documentation(
        self,
        method_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with a Method.

        Edit the documentation associated with a Method.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param method_id: Required.
        :type method_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def edit_documentation(
        self, method_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with a Method.

        Edit the documentation associated with a Method.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param method_id: Required.
        :type method_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_methods_edit_documentation_request(
            method_id=method_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class ModelsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.aio.DyffV0API`'s
        :attr:`models` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    async def label(
        self,
        model_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Model.

        Update labels for an existing Model.

        :param model_id: Required.
        :type model_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def label(
        self,
        model_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        """Update labels for an existing Model.

        Update labels for an existing Model.

        :param model_id: Required.
        :type model_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def label(
        self, model_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Model.

        Update labels for an existing Model.

        :param model_id: Required.
        :type model_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_models_label_request(
            model_id=model_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        name: Optional[str] = None,
        **kwargs: Any,
    ) -> Union[List[JSON], JSON]:
        # pylint: disable=line-too-long
        """Get all Models matching a query.

        Get all Models matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword name: Default value is None.
        :paramtype name: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",  # Account that owns the entity. Required.
                        "artifact": {
                            "kind": "str",  # How the model data is represented.
                              Required. "HuggingFaceCache"
                            "huggingFaceCache": {
                                "repoID": "str",  # Name of the model in the
                                  HuggingFace cache. Required.
                                "revision": "str"  # Model revision. Required.
                            }
                        },
                        "id": "str",  # Unique identifier of the entity. Required.
                        "name": "str",  # The name of the Model. Required.
                        "resources": {
                            "storage": "str",  # Amount of storage required for packaged
                              model, in k8s Quantity notation. Required.
                            "memory": "str"  # Optional. Amount of memory required to run
                              the model on CPU, in k8s Quantity notation.
                        },
                        "source": {
                            "kind": "str",  # The kind of model source. Required. Known
                              values are: "GitLFS", "HuggingFaceHub", "OpenLLM", and "Upload".
                            "gitLFS": {
                                "url": "str"  # The URL of the Git LFS repository.
                                  Required.
                            },
                            "huggingFaceHub": {
                                "repoID": "str",  # Repoid. Required.
                                "revision": "str",  # Revision. Required.
                                "allowPatterns": [
                                    "str"  # Optional. Allowpatterns.
                                ],
                                "ignorePatterns": [
                                    "str"  # Optional. Ignorepatterns.
                                ]
                            },
                            "openLLM": {
                                "modelID": "str",  # The specific model identifier
                                  (c.f. 'openllm build ... --model-id :code:`<modelId>`'). Required.
                                "modelKind": "str",  # The kind of model (c.f.
                                  'openllm build :code:`<modelKind>`'). Required.
                                "modelVersion": "str"  # The version of the model
                                  (e.g., a git commit hash). Required.
                            }
                        },
                        "storage": {
                            "medium": "str"  # Storage medium. Required. Known values
                              are: "ObjectStorage" and "PersistentVolume".
                        },
                        "accelerators": [
                            {
                                "kind": "str",  # The kind of accelerator; available
                                  kinds are {{GPU}}. Required.
                                "gpu": {
                                    "hardwareTypes": [
                                        "str"  # Acceptable GPU hardware
                                          types. Required.
                                    ],
                                    "count": 1,  # Optional. Default value is 1.
                                      Number of GPUs required.
                                    "memory": "str"  # Optional. [DEPRECATED]
                                      Amount of GPU memory required, in k8s Quantity notation.
                                }
                            }
                        ],
                        "annotations": [
                            {
                                "key": "str",  # The annotation key. A DNS label with
                                  an optional DNS domain prefix. For example: 'my-key',
                                  'your.com/key_0'. Names prefixed with 'dyff.io/',
                                  'subdomain.dyff.io/', etc. are reserved.  See
                                  https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                                  for detailed naming rules. Required.
                                "value": "str"  # The annotation value. An arbitrary
                                  string. Required.
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation
                          time (assigned by system).
                        "kind": "Model",  # Optional. Default value is "Model". Kind. "Model"
                        "labels": {
                            "str": "str"  # Optional. A set of key-value labels for the
                              resource. Used to specify identifying attributes of resources that are
                              meaningful to users but do not imply semantics in the dyff system.  The
                              keys are DNS labels with an optional DNS domain prefix. For example:
                              'my-key', 'your.com/key_0'. Keys prefixed with 'dyff.io/',
                              'subdomain.dyff.io/', etc. are reserved.  The label values are
                              alphanumeric characters separated by '.', '-', or '_'.  We follow the
                              kubernetes label conventions closely. See:
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                        },
                        "reason": "str",  # Optional. Reason for current status (assigned by
                          system).
                        "schemaVersion": "0.1",  # Optional. Default value is "0.1". The
                          schema version. "0.1"
                        "status": "str"  # Optional. Top-level resource status (assigned by
                          system).
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_models_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            name=name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a Model.

        Create a Model.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifact": {
                        "kind": "str",  # How the model data is represented. Required.
                          "HuggingFaceCache"
                        "huggingFaceCache": {
                            "repoID": "str",  # Name of the model in the HuggingFace
                              cache. Required.
                            "revision": "str"  # Model revision. Required.
                        }
                    },
                    "name": "str",  # The name of the Model. Required.
                    "resources": {
                        "storage": "str",  # Amount of storage required for packaged model,
                          in k8s Quantity notation. Required.
                        "memory": "str"  # Optional. Amount of memory required to run the
                          model on CPU, in k8s Quantity notation.
                    },
                    "source": {
                        "kind": "str",  # The kind of model source. Required. Known values
                          are: "GitLFS", "HuggingFaceHub", "OpenLLM", and "Upload".
                        "gitLFS": {
                            "url": "str"  # The URL of the Git LFS repository. Required.
                        },
                        "huggingFaceHub": {
                            "repoID": "str",  # Repoid. Required.
                            "revision": "str",  # Revision. Required.
                            "allowPatterns": [
                                "str"  # Optional. Allowpatterns.
                            ],
                            "ignorePatterns": [
                                "str"  # Optional. Ignorepatterns.
                            ]
                        },
                        "openLLM": {
                            "modelID": "str",  # The specific model identifier (c.f.
                              'openllm build ... --model-id :code:`<modelId>`'). Required.
                            "modelKind": "str",  # The kind of model (c.f. 'openllm build
                              :code:`<modelKind>`'). Required.
                            "modelVersion": "str"  # The version of the model (e.g., a
                              git commit hash). Required.
                        }
                    },
                    "storage": {
                        "medium": "str"  # Storage medium. Required. Known values are:
                          "ObjectStorage" and "PersistentVolume".
                    },
                    "accelerators": [
                        {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        }
                    ],
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifact": {
                        "kind": "str",  # How the model data is represented. Required.
                          "HuggingFaceCache"
                        "huggingFaceCache": {
                            "repoID": "str",  # Name of the model in the HuggingFace
                              cache. Required.
                            "revision": "str"  # Model revision. Required.
                        }
                    },
                    "id": "str",  # Unique identifier of the entity. Required.
                    "name": "str",  # The name of the Model. Required.
                    "resources": {
                        "storage": "str",  # Amount of storage required for packaged model,
                          in k8s Quantity notation. Required.
                        "memory": "str"  # Optional. Amount of memory required to run the
                          model on CPU, in k8s Quantity notation.
                    },
                    "source": {
                        "kind": "str",  # The kind of model source. Required. Known values
                          are: "GitLFS", "HuggingFaceHub", "OpenLLM", and "Upload".
                        "gitLFS": {
                            "url": "str"  # The URL of the Git LFS repository. Required.
                        },
                        "huggingFaceHub": {
                            "repoID": "str",  # Repoid. Required.
                            "revision": "str",  # Revision. Required.
                            "allowPatterns": [
                                "str"  # Optional. Allowpatterns.
                            ],
                            "ignorePatterns": [
                                "str"  # Optional. Ignorepatterns.
                            ]
                        },
                        "openLLM": {
                            "modelID": "str",  # The specific model identifier (c.f.
                              'openllm build ... --model-id :code:`<modelId>`'). Required.
                            "modelKind": "str",  # The kind of model (c.f. 'openllm build
                              :code:`<modelKind>`'). Required.
                            "modelVersion": "str"  # The version of the model (e.g., a
                              git commit hash). Required.
                        }
                    },
                    "storage": {
                        "medium": "str"  # Storage medium. Required. Known values are:
                          "ObjectStorage" and "PersistentVolume".
                    },
                    "accelerators": [
                        {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        }
                    ],
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "Model",  # Optional. Default value is "Model". Kind. "Model"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a Model.

        Create a Model.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifact": {
                        "kind": "str",  # How the model data is represented. Required.
                          "HuggingFaceCache"
                        "huggingFaceCache": {
                            "repoID": "str",  # Name of the model in the HuggingFace
                              cache. Required.
                            "revision": "str"  # Model revision. Required.
                        }
                    },
                    "id": "str",  # Unique identifier of the entity. Required.
                    "name": "str",  # The name of the Model. Required.
                    "resources": {
                        "storage": "str",  # Amount of storage required for packaged model,
                          in k8s Quantity notation. Required.
                        "memory": "str"  # Optional. Amount of memory required to run the
                          model on CPU, in k8s Quantity notation.
                    },
                    "source": {
                        "kind": "str",  # The kind of model source. Required. Known values
                          are: "GitLFS", "HuggingFaceHub", "OpenLLM", and "Upload".
                        "gitLFS": {
                            "url": "str"  # The URL of the Git LFS repository. Required.
                        },
                        "huggingFaceHub": {
                            "repoID": "str",  # Repoid. Required.
                            "revision": "str",  # Revision. Required.
                            "allowPatterns": [
                                "str"  # Optional. Allowpatterns.
                            ],
                            "ignorePatterns": [
                                "str"  # Optional. Ignorepatterns.
                            ]
                        },
                        "openLLM": {
                            "modelID": "str",  # The specific model identifier (c.f.
                              'openllm build ... --model-id :code:`<modelId>`'). Required.
                            "modelKind": "str",  # The kind of model (c.f. 'openllm build
                              :code:`<modelKind>`'). Required.
                            "modelVersion": "str"  # The version of the model (e.g., a
                              git commit hash). Required.
                        }
                    },
                    "storage": {
                        "medium": "str"  # Storage medium. Required. Known values are:
                          "ObjectStorage" and "PersistentVolume".
                    },
                    "accelerators": [
                        {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        }
                    ],
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "Model",  # Optional. Default value is "Model". Kind. "Model"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create a Model.

        Create a Model.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifact": {
                        "kind": "str",  # How the model data is represented. Required.
                          "HuggingFaceCache"
                        "huggingFaceCache": {
                            "repoID": "str",  # Name of the model in the HuggingFace
                              cache. Required.
                            "revision": "str"  # Model revision. Required.
                        }
                    },
                    "name": "str",  # The name of the Model. Required.
                    "resources": {
                        "storage": "str",  # Amount of storage required for packaged model,
                          in k8s Quantity notation. Required.
                        "memory": "str"  # Optional. Amount of memory required to run the
                          model on CPU, in k8s Quantity notation.
                    },
                    "source": {
                        "kind": "str",  # The kind of model source. Required. Known values
                          are: "GitLFS", "HuggingFaceHub", "OpenLLM", and "Upload".
                        "gitLFS": {
                            "url": "str"  # The URL of the Git LFS repository. Required.
                        },
                        "huggingFaceHub": {
                            "repoID": "str",  # Repoid. Required.
                            "revision": "str",  # Revision. Required.
                            "allowPatterns": [
                                "str"  # Optional. Allowpatterns.
                            ],
                            "ignorePatterns": [
                                "str"  # Optional. Ignorepatterns.
                            ]
                        },
                        "openLLM": {
                            "modelID": "str",  # The specific model identifier (c.f.
                              'openllm build ... --model-id :code:`<modelId>`'). Required.
                            "modelKind": "str",  # The kind of model (c.f. 'openllm build
                              :code:`<modelKind>`'). Required.
                            "modelVersion": "str"  # The version of the model (e.g., a
                              git commit hash). Required.
                        }
                    },
                    "storage": {
                        "medium": "str"  # Storage medium. Required. Known values are:
                          "ObjectStorage" and "PersistentVolume".
                    },
                    "accelerators": [
                        {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        }
                    ],
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifact": {
                        "kind": "str",  # How the model data is represented. Required.
                          "HuggingFaceCache"
                        "huggingFaceCache": {
                            "repoID": "str",  # Name of the model in the HuggingFace
                              cache. Required.
                            "revision": "str"  # Model revision. Required.
                        }
                    },
                    "id": "str",  # Unique identifier of the entity. Required.
                    "name": "str",  # The name of the Model. Required.
                    "resources": {
                        "storage": "str",  # Amount of storage required for packaged model,
                          in k8s Quantity notation. Required.
                        "memory": "str"  # Optional. Amount of memory required to run the
                          model on CPU, in k8s Quantity notation.
                    },
                    "source": {
                        "kind": "str",  # The kind of model source. Required. Known values
                          are: "GitLFS", "HuggingFaceHub", "OpenLLM", and "Upload".
                        "gitLFS": {
                            "url": "str"  # The URL of the Git LFS repository. Required.
                        },
                        "huggingFaceHub": {
                            "repoID": "str",  # Repoid. Required.
                            "revision": "str",  # Revision. Required.
                            "allowPatterns": [
                                "str"  # Optional. Allowpatterns.
                            ],
                            "ignorePatterns": [
                                "str"  # Optional. Ignorepatterns.
                            ]
                        },
                        "openLLM": {
                            "modelID": "str",  # The specific model identifier (c.f.
                              'openllm build ... --model-id :code:`<modelId>`'). Required.
                            "modelKind": "str",  # The kind of model (c.f. 'openllm build
                              :code:`<modelKind>`'). Required.
                            "modelVersion": "str"  # The version of the model (e.g., a
                              git commit hash). Required.
                        }
                    },
                    "storage": {
                        "medium": "str"  # Storage medium. Required. Known values are:
                          "ObjectStorage" and "PersistentVolume".
                    },
                    "accelerators": [
                        {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        }
                    ],
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "Model",  # Optional. Default value is "Model". Kind. "Model"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_models_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get(self, model_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get a Model by its key.

        Get a Model by its key.

        Raises a 404 error if no entity exists with that key.

        :param model_id: Required.
        :type model_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifact": {
                        "kind": "str",  # How the model data is represented. Required.
                          "HuggingFaceCache"
                        "huggingFaceCache": {
                            "repoID": "str",  # Name of the model in the HuggingFace
                              cache. Required.
                            "revision": "str"  # Model revision. Required.
                        }
                    },
                    "id": "str",  # Unique identifier of the entity. Required.
                    "name": "str",  # The name of the Model. Required.
                    "resources": {
                        "storage": "str",  # Amount of storage required for packaged model,
                          in k8s Quantity notation. Required.
                        "memory": "str"  # Optional. Amount of memory required to run the
                          model on CPU, in k8s Quantity notation.
                    },
                    "source": {
                        "kind": "str",  # The kind of model source. Required. Known values
                          are: "GitLFS", "HuggingFaceHub", "OpenLLM", and "Upload".
                        "gitLFS": {
                            "url": "str"  # The URL of the Git LFS repository. Required.
                        },
                        "huggingFaceHub": {
                            "repoID": "str",  # Repoid. Required.
                            "revision": "str",  # Revision. Required.
                            "allowPatterns": [
                                "str"  # Optional. Allowpatterns.
                            ],
                            "ignorePatterns": [
                                "str"  # Optional. Ignorepatterns.
                            ]
                        },
                        "openLLM": {
                            "modelID": "str",  # The specific model identifier (c.f.
                              'openllm build ... --model-id :code:`<modelId>`'). Required.
                            "modelKind": "str",  # The kind of model (c.f. 'openllm build
                              :code:`<modelKind>`'). Required.
                            "modelVersion": "str"  # The version of the model (e.g., a
                              git commit hash). Required.
                        }
                    },
                    "storage": {
                        "medium": "str"  # Storage medium. Required. Known values are:
                          "ObjectStorage" and "PersistentVolume".
                    },
                    "accelerators": [
                        {
                            "kind": "str",  # The kind of accelerator; available kinds
                              are {{GPU}}. Required.
                            "gpu": {
                                "hardwareTypes": [
                                    "str"  # Acceptable GPU hardware types.
                                      Required.
                                ],
                                "count": 1,  # Optional. Default value is 1. Number
                                  of GPUs required.
                                "memory": "str"  # Optional. [DEPRECATED] Amount of
                                  GPU memory required, in k8s Quantity notation.
                            }
                        }
                    ],
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "Model",  # Optional. Default value is "Model". Kind. "Model"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_models_get_request(
            model_id=model_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete(self, model_id: str, **kwargs: Any) -> JSON:
        """Mark a Model for deletion.

        Mark a Model for deletion.

        :param model_id: Required.
        :type model_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_models_delete_request(
            model_id=model_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def documentation(self, model_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get the documentation associated with a Model.

        Get the documentation associated with a Model.

        Raises a 404 error if no entity exists with that key.

        :param model_id: Required.
        :type model_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_models_documentation_request(
            model_id=model_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def edit_documentation(
        self,
        model_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with a Model.

        Edit the documentation associated with a Model.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param model_id: Required.
        :type model_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def edit_documentation(
        self,
        model_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with a Model.

        Edit the documentation associated with a Model.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param model_id: Required.
        :type model_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def edit_documentation(
        self, model_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with a Model.

        Edit the documentation associated with a Model.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param model_id: Required.
        :type model_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_models_edit_documentation_request(
            model_id=model_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class ModulesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.aio.DyffV0API`'s
        :attr:`modules` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    async def label(
        self,
        module_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Module.

        Update labels for an existing Module.

        :param module_id: Required.
        :type module_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def label(
        self,
        module_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        """Update labels for an existing Module.

        Update labels for an existing Module.

        :param module_id: Required.
        :type module_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def label(
        self, module_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Module.

        Update labels for an existing Module.

        :param module_id: Required.
        :type module_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_modules_label_request(
            module_id=module_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        name: Optional[str] = None,
        **kwargs: Any,
    ) -> Union[List[JSON], JSON]:
        # pylint: disable=line-too-long
        """Get all Modules matching a query.

        Get all Modules matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword name: Default value is None.
        :paramtype name: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",  # Account that owns the entity. Required.
                        "artifacts": [
                            {
                                "path": "str",  # The relative path of the artifact
                                  within the tree. Required.
                                "digest": {
                                    "md5": "str"  # Optional. md5 digest of
                                      artifact data.
                                },
                                "kind": "str"  # Optional. The kind of artifact.
                            }
                        ],
                        "id": "str",  # Unique identifier of the entity. Required.
                        "name": "str",  # The name of the Module. Required.
                        "annotations": [
                            {
                                "key": "str",  # The annotation key. A DNS label with
                                  an optional DNS domain prefix. For example: 'my-key',
                                  'your.com/key_0'. Names prefixed with 'dyff.io/',
                                  'subdomain.dyff.io/', etc. are reserved.  See
                                  https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                                  for detailed naming rules. Required.
                                "value": "str"  # The annotation value. An arbitrary
                                  string. Required.
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation
                          time (assigned by system).
                        "kind": "Module",  # Optional. Default value is "Module". Kind.
                          "Module"
                        "labels": {
                            "str": "str"  # Optional. A set of key-value labels for the
                              resource. Used to specify identifying attributes of resources that are
                              meaningful to users but do not imply semantics in the dyff system.  The
                              keys are DNS labels with an optional DNS domain prefix. For example:
                              'my-key', 'your.com/key_0'. Keys prefixed with 'dyff.io/',
                              'subdomain.dyff.io/', etc. are reserved.  The label values are
                              alphanumeric characters separated by '.', '-', or '_'.  We follow the
                              kubernetes label conventions closely. See:
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                        },
                        "reason": "str",  # Optional. Reason for current status (assigned by
                          system).
                        "schemaVersion": "0.1",  # Optional. Default value is "0.1". The
                          schema version. "0.1"
                        "status": "str"  # Optional. Top-level resource status (assigned by
                          system).
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_modules_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            name=name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a Module.

        Create a Module.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifacts": [
                        {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        }
                    ],
                    "name": "str",  # The name of the Module. Required.
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifacts": [
                        {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        }
                    ],
                    "id": "str",  # Unique identifier of the entity. Required.
                    "name": "str",  # The name of the Module. Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "Module",  # Optional. Default value is "Module". Kind. "Module"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a Module.

        Create a Module.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifacts": [
                        {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        }
                    ],
                    "id": "str",  # Unique identifier of the entity. Required.
                    "name": "str",  # The name of the Module. Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "Module",  # Optional. Default value is "Module". Kind. "Module"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create a Module.

        Create a Module.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifacts": [
                        {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        }
                    ],
                    "name": "str",  # The name of the Module. Required.
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifacts": [
                        {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        }
                    ],
                    "id": "str",  # Unique identifier of the entity. Required.
                    "name": "str",  # The name of the Module. Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "Module",  # Optional. Default value is "Module". Kind. "Module"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_modules_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get(self, module_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get a Module by its key.

        Get a Module by its key.

        Raises a 404 error if no entity exists with that key.

        :param module_id: Required.
        :type module_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "artifacts": [
                        {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        }
                    ],
                    "id": "str",  # Unique identifier of the entity. Required.
                    "name": "str",  # The name of the Module. Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "kind": "Module",  # Optional. Default value is "Module". Kind. "Module"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_modules_get_request(
            module_id=module_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete(self, module_id: str, **kwargs: Any) -> JSON:
        """Mark a Module for deletion.

        Mark a Module for deletion.

        :param module_id: Required.
        :type module_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_modules_delete_request(
            module_id=module_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def upload(self, module_id: str, artifact_path: str, **kwargs: Any) -> JSON:
        """Get a signed URL to which the given artifact can be uploaded.

        Get a signed URL to which the given artifact can be uploaded.

        :param module_id: Required.
        :type module_id: str
        :param artifact_path: Required.
        :type artifact_path: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "method": "str",  # The HTTP method applicable to the URL. Required.
                    "url": "str",  # The signed URL. Required.
                    "headers": {
                        "str": "str"  # Optional. Mandatory headers that must be passed with
                          the request.
                    }
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_modules_upload_request(
            module_id=module_id,
            artifact_path=artifact_path,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def finalize(self, module_id: str, **kwargs: Any) -> Union[Any, JSON]:
        """Indicate that all module artifacts have been uploaded.

        Indicate that all module artifacts have been uploaded.

        :param module_id: Required.
        :type module_id: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        _request = build_modules_finalize_request(
            module_id=module_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def downlinks(self, module_id: str, **kwargs: Any) -> Union[List[JSON], JSON]:
        """Get a list of signed GET URLs from which Module artifacts can be downloaded.

        Get a list of signed GET URLs from which Module artifacts can be downloaded.

        :param module_id: Required.
        :type module_id: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "artifact": {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        },
                        "signedURL": {
                            "method": "str",  # The HTTP method applicable to the URL.
                              Required.
                            "url": "str",  # The signed URL. Required.
                            "headers": {
                                "str": "str"  # Optional. Mandatory headers that must
                                  be passed with the request.
                            }
                        }
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_modules_downlinks_request(
            module_id=module_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def documentation(self, module_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get the documentation associated with a Module.

        Get the documentation associated with a Module.

        Raises a 404 error if no entity exists with that key.

        :param module_id: Required.
        :type module_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_modules_documentation_request(
            module_id=module_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def edit_documentation(
        self,
        module_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with a Module.

        Edit the documentation associated with a Module.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param module_id: Required.
        :type module_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def edit_documentation(
        self,
        module_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with a Module.

        Edit the documentation associated with a Module.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param module_id: Required.
        :type module_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def edit_documentation(
        self, module_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Edit the documentation associated with a Module.

        Edit the documentation associated with a Module.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param module_id: Required.
        :type module_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }

                # response body for status code(s): 200
                response == {
                    "fullPage": "str",  # Optional. Long-form documentation. Interpreted as
                      Markdown. There are no length constraints, but be reasonable.
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "summary": "str",  # Optional. A brief summary, suitable for display in small
                      UI elements. Interpreted as Markdown. Excessively long summaries may be truncated
                      in the UI, especially on small displays.
                    "title": "str"  # Optional. A short plain string suitable as a title or
                      "headline".
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_modules_edit_documentation_request(
            module_id=module_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class ReportsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.aio.DyffV0API`'s
        :attr:`reports` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    async def label(
        self,
        report_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Report.

        Update labels for an existing Report.

        :param report_id: Required.
        :type report_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def label(
        self,
        report_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        """Update labels for an existing Report.

        Update labels for an existing Report.

        :param report_id: Required.
        :type report_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def label(
        self, report_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing Report.

        Update labels for an existing Report.

        :param report_id: Required.
        :type report_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_reports_label_request(
            report_id=report_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        report: Optional[str] = None,
        dataset: Optional[str] = None,
        evaluation: Optional[str] = None,
        inference_service: Optional[str] = None,
        model: Optional[str] = None,
        **kwargs: Any,
    ) -> Union[List[JSON], JSON]:
        # pylint: disable=line-too-long
        """Get all Reports matching a query.

        Get all Reports matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword report: Default value is None.
        :paramtype report: str
        :keyword dataset: Default value is None.
        :paramtype dataset: str
        :keyword evaluation: Default value is None.
        :paramtype evaluation: str
        :keyword inference_service: Default value is None.
        :paramtype inference_service: str
        :keyword model: Default value is None.
        :paramtype model: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",  # Account that owns the entity. Required.
                        "dataset": "str",  # The input dataset. Required.
                        "evaluation": "str",  # The evaluation (and corresponding output
                          data) to run the report on. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "inferenceService": "str",  # The inference service used in the
                          evaluation. Required.
                        "rubric": "str",  # The scoring rubric to apply (e.g.,
                          'classification.TopKAccuracy'). Required.
                        "annotations": [
                            {
                                "key": "str",  # The annotation key. A DNS label with
                                  an optional DNS domain prefix. For example: 'my-key',
                                  'your.com/key_0'. Names prefixed with 'dyff.io/',
                                  'subdomain.dyff.io/', etc. are reserved.  See
                                  https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                                  for detailed naming rules. Required.
                                "value": "str"  # The annotation value. An arbitrary
                                  string. Required.
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation
                          time (assigned by system).
                        "datasetView": {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        },
                        "evaluationView": {
                            "id": "str",  # Unique ID of the DataView. Required.
                            "schema": {
                                "arrowSchema": "str",  # The schema in Arrow format,
                                  encoded with dyff.schema.arrow.encode_schema(). This is required, but
                                  can be populated from a DyffDataSchema. Required.
                                "dyffSchema": {
                                    "components": [
                                        "str"  # A list of named dyff data
                                          schemas. The final schema is the composition of these
                                          component schemas. Required.
                                    ],
                                    "schemaVersion": "0.1"  # Optional. Default
                                      value is "0.1". The dyff schema version. "0.1"
                                },
                                "jsonSchema": {}  # Optional. The schema in JSON
                                  Schema format.
                            },
                            "viewOf": "str",  # ID of the resource that this is a view
                              of. Required.
                            "adapterPipeline": [
                                {
                                    "kind": "str",  # Name of a schema adapter
                                      available on the platform. Required.
                                    "configuration": {}  # Optional.
                                      Configuration for the schema adapter. Must be encodable as JSON.
                                }
                            ]
                        },
                        "kind": "Report",  # Optional. Default value is "Report". Kind.
                          "Report"
                        "labels": {
                            "str": "str"  # Optional. A set of key-value labels for the
                              resource. Used to specify identifying attributes of resources that are
                              meaningful to users but do not imply semantics in the dyff system.  The
                              keys are DNS labels with an optional DNS domain prefix. For example:
                              'my-key', 'your.com/key_0'. Keys prefixed with 'dyff.io/',
                              'subdomain.dyff.io/', etc. are reserved.  The label values are
                              alphanumeric characters separated by '.', '-', or '_'.  We follow the
                              kubernetes label conventions closely. See:
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                        },
                        "model": "str",  # Optional. The model backing the inference service,
                          if applicable.
                        "modules": [
                            "str"  # Optional. Additional modules to load into the report
                              environment.
                        ],
                        "reason": "str",  # Optional. Reason for current status (assigned by
                          system).
                        "schemaVersion": "0.1",  # Optional. Default value is "0.1". The
                          schema version. "0.1"
                        "status": "str"  # Optional. Top-level resource status (assigned by
                          system).
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_reports_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            report=report,
            dataset=dataset,
            evaluation=evaluation,
            inference_service=inference_service,
            model=model,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a Report.

        Create a Report.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "evaluation": "str",  # The evaluation (and corresponding output data) to run
                      the report on. Required.
                    "rubric": "str",  # The scoring rubric to apply (e.g.,
                      'classification.TopKAccuracy'). Required.
                    "datasetView": {},
                    "evaluationView": {},
                    "modules": [
                        "str"  # Optional. Additional modules to load into the report
                          environment.
                    ],
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "dataset": "str",  # The input dataset. Required.
                    "evaluation": "str",  # The evaluation (and corresponding output data) to run
                      the report on. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "inferenceService": "str",  # The inference service used in the evaluation.
                      Required.
                    "rubric": "str",  # The scoring rubric to apply (e.g.,
                      'classification.TopKAccuracy'). Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "datasetView": {
                        "id": "str",  # Unique ID of the DataView. Required.
                        "schema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "viewOf": "str",  # ID of the resource that this is a view of.
                          Required.
                        "adapterPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "evaluationView": {
                        "id": "str",  # Unique ID of the DataView. Required.
                        "schema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "viewOf": "str",  # ID of the resource that this is a view of.
                          Required.
                        "adapterPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "kind": "Report",  # Optional. Default value is "Report". Kind. "Report"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "model": "str",  # Optional. The model backing the inference service, if
                      applicable.
                    "modules": [
                        "str"  # Optional. Additional modules to load into the report
                          environment.
                    ],
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a Report.

        Create a Report.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "dataset": "str",  # The input dataset. Required.
                    "evaluation": "str",  # The evaluation (and corresponding output data) to run
                      the report on. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "inferenceService": "str",  # The inference service used in the evaluation.
                      Required.
                    "rubric": "str",  # The scoring rubric to apply (e.g.,
                      'classification.TopKAccuracy'). Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "datasetView": {
                        "id": "str",  # Unique ID of the DataView. Required.
                        "schema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "viewOf": "str",  # ID of the resource that this is a view of.
                          Required.
                        "adapterPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "evaluationView": {
                        "id": "str",  # Unique ID of the DataView. Required.
                        "schema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "viewOf": "str",  # ID of the resource that this is a view of.
                          Required.
                        "adapterPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "kind": "Report",  # Optional. Default value is "Report". Kind. "Report"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "model": "str",  # Optional. The model backing the inference service, if
                      applicable.
                    "modules": [
                        "str"  # Optional. Additional modules to load into the report
                          environment.
                    ],
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create a Report.

        Create a Report.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "evaluation": "str",  # The evaluation (and corresponding output data) to run
                      the report on. Required.
                    "rubric": "str",  # The scoring rubric to apply (e.g.,
                      'classification.TopKAccuracy'). Required.
                    "datasetView": {},
                    "evaluationView": {},
                    "modules": [
                        "str"  # Optional. Additional modules to load into the report
                          environment.
                    ],
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "dataset": "str",  # The input dataset. Required.
                    "evaluation": "str",  # The evaluation (and corresponding output data) to run
                      the report on. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "inferenceService": "str",  # The inference service used in the evaluation.
                      Required.
                    "rubric": "str",  # The scoring rubric to apply (e.g.,
                      'classification.TopKAccuracy'). Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "datasetView": {
                        "id": "str",  # Unique ID of the DataView. Required.
                        "schema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "viewOf": "str",  # ID of the resource that this is a view of.
                          Required.
                        "adapterPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "evaluationView": {
                        "id": "str",  # Unique ID of the DataView. Required.
                        "schema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "viewOf": "str",  # ID of the resource that this is a view of.
                          Required.
                        "adapterPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "kind": "Report",  # Optional. Default value is "Report". Kind. "Report"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "model": "str",  # Optional. The model backing the inference service, if
                      applicable.
                    "modules": [
                        "str"  # Optional. Additional modules to load into the report
                          environment.
                    ],
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_reports_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get(self, report_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get a Report by its key.

        Get a Report by its key.

        Raises a 404 error if no entity exists with that key.

        :param report_id: Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "dataset": "str",  # The input dataset. Required.
                    "evaluation": "str",  # The evaluation (and corresponding output data) to run
                      the report on. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "inferenceService": "str",  # The inference service used in the evaluation.
                      Required.
                    "rubric": "str",  # The scoring rubric to apply (e.g.,
                      'classification.TopKAccuracy'). Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "datasetView": {
                        "id": "str",  # Unique ID of the DataView. Required.
                        "schema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "viewOf": "str",  # ID of the resource that this is a view of.
                          Required.
                        "adapterPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "evaluationView": {
                        "id": "str",  # Unique ID of the DataView. Required.
                        "schema": {
                            "arrowSchema": "str",  # The schema in Arrow format, encoded
                              with dyff.schema.arrow.encode_schema(). This is required, but can be
                              populated from a DyffDataSchema. Required.
                            "dyffSchema": {
                                "components": [
                                    "str"  # A list of named dyff data schemas.
                                      The final schema is the composition of these component schemas.
                                      Required.
                                ],
                                "schemaVersion": "0.1"  # Optional. Default value is
                                  "0.1". The dyff schema version. "0.1"
                            },
                            "jsonSchema": {}  # Optional. The schema in JSON Schema
                              format.
                        },
                        "viewOf": "str",  # ID of the resource that this is a view of.
                          Required.
                        "adapterPipeline": [
                            {
                                "kind": "str",  # Name of a schema adapter available
                                  on the platform. Required.
                                "configuration": {}  # Optional. Configuration for
                                  the schema adapter. Must be encodable as JSON.
                            }
                        ]
                    },
                    "kind": "Report",  # Optional. Default value is "Report". Kind. "Report"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "model": "str",  # Optional. The model backing the inference service, if
                      applicable.
                    "modules": [
                        "str"  # Optional. Additional modules to load into the report
                          environment.
                    ],
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete(self, report_id: str, **kwargs: Any) -> JSON:
        """Mark a Report for deletion.

        Mark a Report for deletion.

        :param report_id: Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_delete_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def downlinks(self, report_id: str, **kwargs: Any) -> Union[List[JSON], JSON]:
        """Get a list of signed GET URLs from which Report artifacts can be downloaded.

        Get a list of signed GET URLs from which Report artifacts can be downloaded.

        :param report_id: Required.
        :type report_id: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "artifact": {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        },
                        "signedURL": {
                            "method": "str",  # The HTTP method applicable to the URL.
                              Required.
                            "url": "str",  # The signed URL. Required.
                            "headers": {
                                "str": "str"  # Optional. Mandatory headers that must
                                  be passed with the request.
                            }
                        }
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_reports_downlinks_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def logs(self, report_id: str, **kwargs: Any) -> JSON:
        """Get a signed GET URL from which the logs file for the report run can be
        downloaded.

        Get a signed GET URL from which the logs file for the report run can be downloaded.

        :param report_id: Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "artifact": {
                        "path": "str",  # The relative path of the artifact within the tree.
                          Required.
                        "digest": {
                            "md5": "str"  # Optional. md5 digest of artifact data.
                        },
                        "kind": "str"  # Optional. The kind of artifact.
                    },
                    "signedURL": {
                        "method": "str",  # The HTTP method applicable to the URL. Required.
                        "url": "str",  # The signed URL. Required.
                        "headers": {
                            "str": "str"  # Optional. Mandatory headers that must be
                              passed with the request.
                        }
                    }
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_logs_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class SafetycasesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.aio.DyffV0API`'s
        :attr:`safetycases` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    async def label(
        self,
        safetycase_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing SafetyCase.

        Update labels for an existing SafetyCase.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def label(
        self,
        safetycase_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[Any, JSON]:
        """Update labels for an existing SafetyCase.

        Update labels for an existing SafetyCase.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def label(
        self, safetycase_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Union[Any, JSON]:
        # pylint: disable=line-too-long
        """Update labels for an existing SafetyCase.

        Update labels for an existing SafetyCase.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any or JSON object
        :rtype: any or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "schemaVersion": "0.1"  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                }

                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[Any, JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_safetycases_label_request(
            safetycase_id=safetycase_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[Any, JSON], deserialized), {})  # type: ignore

        return cast(Union[Any, JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        method: Optional[str] = None,
        method_name: Optional[str] = None,
        dataset: Optional[str] = None,
        evaluation: Optional[str] = None,
        inference_service: Optional[str] = None,
        model: Optional[str] = None,
        inputs: Optional[str] = None,
        **kwargs: Any,
    ) -> Union[List[JSON], JSON]:
        # pylint: disable=line-too-long
        """Get all SafetyCase entities matching a query.

        Get all SafetyCase entities matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword method: Default value is None.
        :paramtype method: str
        :keyword method_name: Default value is None.
        :paramtype method_name: str
        :keyword dataset: Default value is None.
        :paramtype dataset: str
        :keyword evaluation: Default value is None.
        :paramtype evaluation: str
        :keyword inference_service: Default value is None.
        :paramtype inference_service: str
        :keyword model: Default value is None.
        :paramtype model: str
        :keyword inputs: Default value is None.
        :paramtype inputs: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "method": {
                            "account": "str",  # Account that owns the entity. Required.
                            "id": "str",  # Unique identifier of the entity. Required.
                            "implementation": {
                                "kind": "str",  # The kind of implementation.
                                  Required.
                                "jupyterNotebook": {
                                    "notebookModule": "str",  # ID of the Module
                                      that contains the notebook file. This does *not* add the Module
                                      as a dependency; you must do that separately. Required.
                                    "notebookPath": "str"  # Path to the notebook
                                      file relative to the Module root directory. Required.
                                },
                                "pythonFunction": {
                                    "fullyQualifiedName": "str"  # The
                                      fully-qualified name of the Python function to call. Required.
                                },
                                "pythonRubric": {
                                    "fullyQualifiedName": "str"  # The
                                      fully-qualified name of the Python Rubric to run. Required.
                                }
                            },
                            "name": "str",  # Descriptive name of the Method. Required.
                            "output": {
                                "kind": "str",  # The kind of output artifact.
                                  Required. Known values are: "Measurement" and "SafetyCase".
                                "measurement": {
                                    "level": "str",  # Measurement level.
                                      Required. Known values are: "Dataset" and "Instance".
                                    "name": "str",  # Descriptive name of the
                                      Measurement. Required.
                                    "schema": {
                                        "arrowSchema": "str",  # The schema
                                          in Arrow format, encoded with
                                          dyff.schema.arrow.encode_schema(). This is required, but can
                                          be populated from a DyffDataSchema. Required.
                                        "dyffSchema": {
                                            "components": [
                                                "str"  # A list of
                                                  named dyff data schemas. The final schema is the
                                                  composition of these component schemas. Required.
                                            ],
                                            "schemaVersion": "0.1"  #
                                              Optional. Default value is "0.1". The dyff schema
                                              version. "0.1"
                                        },
                                        "jsonSchema": {}  # Optional. The
                                          schema in JSON Schema format.
                                    },
                                    "description": "str"  # Optional. Long-form
                                      description, interpreted as Markdown.
                                },
                                "safetyCase": {
                                    "name": "str",  # Descriptive name of the
                                      SafetyCase. Required.
                                    "description": "str"  # Optional. Long-form
                                      description, interpreted as Markdown.
                                }
                            },
                            "scope": "str",  # The scope of the Method. The Method
                              produces outputs that are specific to one entity of the type specified in
                              the .scope field. Required. Known values are: "InferenceService" and
                              "Evaluation".
                            "description": "str",  # Optional. Long-form description,
                              interpreted as Markdown.
                            "inputs": [
                                {
                                    "keyword": "str",  # The input is referred to
                                      by 'keyword' in the context of the method implementation.
                                      Required.
                                    "kind": "str",  # The kind of input artifact.
                                      Required. Known values are: "Dataset", "Evaluation",
                                      "Measurement", and "Report".
                                    "description": "str"  # Optional. Long-form
                                      description, interpreted as Markdown.
                                }
                            ],
                            "modules": [
                                "str"  # Optional. Modules to load into the analysis
                                  environment.
                            ],
                            "parameters": [
                                {
                                    "keyword": "str",  # The parameter is
                                      referred to by 'keyword' in the context of the method
                                      implementation. Required.
                                    "description": "str"  # Optional. Long-form
                                      description, interpreted as Markdown.
                                }
                            ]
                        },
                        "name": "str",  # Descriptive name of the SafetyCase. Required.
                        "annotations": [
                            {
                                "key": "str",  # The annotation key. A DNS label with
                                  an optional DNS domain prefix. For example: 'my-key',
                                  'your.com/key_0'. Names prefixed with 'dyff.io/',
                                  'subdomain.dyff.io/', etc. are reserved.  See
                                  https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                                  for detailed naming rules. Required.
                                "value": "str"  # The annotation value. An arbitrary
                                  string. Required.
                            }
                        ],
                        "arguments": [
                            {
                                "keyword": "str",  # The 'keyword' of the
                                  corresponding ModelParameter. Required.
                                "value": "str"  # The value of of the argument.
                                  Always a string; implementations are responsible for parsing.
                                  Required.
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation
                          time (assigned by system).
                        "description": "str",  # Optional. Long-form description, interpreted
                          as Markdown.
                        "inputs": [
                            {
                                "entity": "str",  # The ID of the entity whose data
                                  should be made available as 'keyword'. Required.
                                "keyword": "str"  # The 'keyword' specified for this
                                  input in the MethodSpec. Required.
                            }
                        ],
                        "kind": "SafetyCase",  # Optional. Default value is "SafetyCase".
                          Kind. "SafetyCase"
                        "labels": {
                            "str": "str"  # Optional. A set of key-value labels for the
                              resource. Used to specify identifying attributes of resources that are
                              meaningful to users but do not imply semantics in the dyff system.  The
                              keys are DNS labels with an optional DNS domain prefix. For example:
                              'my-key', 'your.com/key_0'. Keys prefixed with 'dyff.io/',
                              'subdomain.dyff.io/', etc. are reserved.  The label values are
                              alphanumeric characters separated by '.', '-', or '_'.  We follow the
                              kubernetes label conventions closely. See:
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                        },
                        "reason": "str",  # Optional. Reason for current status (assigned by
                          system).
                        "schemaVersion": "0.1",  # Optional. Default value is "0.1". The
                          schema version. "0.1"
                        "scope": {
                            "dataset": "str",  # Optional. The Dataset to which the
                              analysis applies.
                            "evaluation": "str",  # Optional. The Evaluation to which the
                              analysis applies.
                            "inferenceService": "str",  # Optional. The InferenceService
                              to which the analysis applies.
                            "model": "str"  # Optional. The Model to which the analysis
                              applies.
                        },
                        "status": "str"  # Optional. Top-level resource status (assigned by
                          system).
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_safetycases_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            method=method,
            method_name=method_name,
            dataset=dataset,
            evaluation=evaluation,
            inference_service=inference_service,
            model=model,
            inputs=inputs,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a SafetyCase.

        Create a SafetyCase.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "method": "str",  # Method ID. Required.
                    "arguments": [
                        {
                            "keyword": "str",  # The 'keyword' of the corresponding
                              ModelParameter. Required.
                            "value": "str"  # The value of of the argument. Always a
                              string; implementations are responsible for parsing. Required.
                        }
                    ],
                    "inputs": [
                        {
                            "entity": "str",  # The ID of the entity whose data should be
                              made available as 'keyword'. Required.
                            "keyword": "str"  # The 'keyword' specified for this input in
                              the MethodSpec. Required.
                        }
                    ],
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "scope": {
                        "dataset": "str",  # Optional. The Dataset to which the analysis
                          applies.
                        "evaluation": "str",  # Optional. The Evaluation to which the
                          analysis applies.
                        "inferenceService": "str",  # Optional. The InferenceService to which
                          the analysis applies.
                        "model": "str"  # Optional. The Model to which the analysis applies.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "method": {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "implementation": {
                            "kind": "str",  # The kind of implementation. Required.
                            "jupyterNotebook": {
                                "notebookModule": "str",  # ID of the Module that
                                  contains the notebook file. This does *not* add the Module as a
                                  dependency; you must do that separately. Required.
                                "notebookPath": "str"  # Path to the notebook file
                                  relative to the Module root directory. Required.
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python function to call. Required.
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python Rubric to run. Required.
                            }
                        },
                        "name": "str",  # Descriptive name of the Method. Required.
                        "output": {
                            "kind": "str",  # The kind of output artifact. Required.
                              Known values are: "Measurement" and "SafetyCase".
                            "measurement": {
                                "level": "str",  # Measurement level. Required. Known
                                  values are: "Dataset" and "Instance".
                                "name": "str",  # Descriptive name of the
                                  Measurement. Required.
                                "schema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            },
                            "safetyCase": {
                                "name": "str",  # Descriptive name of the SafetyCase.
                                  Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        },
                        "scope": "str",  # The scope of the Method. The Method produces
                          outputs that are specific to one entity of the type specified in the .scope
                          field. Required. Known values are: "InferenceService" and "Evaluation".
                        "description": "str",  # Optional. Long-form description, interpreted
                          as Markdown.
                        "inputs": [
                            {
                                "keyword": "str",  # The input is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "kind": "str",  # The kind of input artifact.
                                  Required. Known values are: "Dataset", "Evaluation", "Measurement",
                                  and "Report".
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ],
                        "modules": [
                            "str"  # Optional. Modules to load into the analysis
                              environment.
                        ],
                        "parameters": [
                            {
                                "keyword": "str",  # The parameter is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ]
                    },
                    "name": "str",  # Descriptive name of the SafetyCase. Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",  # The 'keyword' of the corresponding
                              ModelParameter. Required.
                            "value": "str"  # The value of of the argument. Always a
                              string; implementations are responsible for parsing. Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "entity": "str",  # The ID of the entity whose data should be
                              made available as 'keyword'. Required.
                            "keyword": "str"  # The 'keyword' specified for this input in
                              the MethodSpec. Required.
                        }
                    ],
                    "kind": "SafetyCase",  # Optional. Default value is "SafetyCase". Kind.
                      "SafetyCase"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "scope": {
                        "dataset": "str",  # Optional. The Dataset to which the analysis
                          applies.
                        "evaluation": "str",  # Optional. The Evaluation to which the
                          analysis applies.
                        "inferenceService": "str",  # Optional. The InferenceService to which
                          the analysis applies.
                        "model": "str"  # Optional. The Model to which the analysis applies.
                    },
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a SafetyCase.

        Create a SafetyCase.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "method": {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "implementation": {
                            "kind": "str",  # The kind of implementation. Required.
                            "jupyterNotebook": {
                                "notebookModule": "str",  # ID of the Module that
                                  contains the notebook file. This does *not* add the Module as a
                                  dependency; you must do that separately. Required.
                                "notebookPath": "str"  # Path to the notebook file
                                  relative to the Module root directory. Required.
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python function to call. Required.
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python Rubric to run. Required.
                            }
                        },
                        "name": "str",  # Descriptive name of the Method. Required.
                        "output": {
                            "kind": "str",  # The kind of output artifact. Required.
                              Known values are: "Measurement" and "SafetyCase".
                            "measurement": {
                                "level": "str",  # Measurement level. Required. Known
                                  values are: "Dataset" and "Instance".
                                "name": "str",  # Descriptive name of the
                                  Measurement. Required.
                                "schema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            },
                            "safetyCase": {
                                "name": "str",  # Descriptive name of the SafetyCase.
                                  Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        },
                        "scope": "str",  # The scope of the Method. The Method produces
                          outputs that are specific to one entity of the type specified in the .scope
                          field. Required. Known values are: "InferenceService" and "Evaluation".
                        "description": "str",  # Optional. Long-form description, interpreted
                          as Markdown.
                        "inputs": [
                            {
                                "keyword": "str",  # The input is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "kind": "str",  # The kind of input artifact.
                                  Required. Known values are: "Dataset", "Evaluation", "Measurement",
                                  and "Report".
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ],
                        "modules": [
                            "str"  # Optional. Modules to load into the analysis
                              environment.
                        ],
                        "parameters": [
                            {
                                "keyword": "str",  # The parameter is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ]
                    },
                    "name": "str",  # Descriptive name of the SafetyCase. Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",  # The 'keyword' of the corresponding
                              ModelParameter. Required.
                            "value": "str"  # The value of of the argument. Always a
                              string; implementations are responsible for parsing. Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "entity": "str",  # The ID of the entity whose data should be
                              made available as 'keyword'. Required.
                            "keyword": "str"  # The 'keyword' specified for this input in
                              the MethodSpec. Required.
                        }
                    ],
                    "kind": "SafetyCase",  # Optional. Default value is "SafetyCase". Kind.
                      "SafetyCase"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "scope": {
                        "dataset": "str",  # Optional. The Dataset to which the analysis
                          applies.
                        "evaluation": "str",  # Optional. The Evaluation to which the
                          analysis applies.
                        "inferenceService": "str",  # Optional. The InferenceService to which
                          the analysis applies.
                        "model": "str"  # Optional. The Model to which the analysis applies.
                    },
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create a SafetyCase.

        Create a SafetyCase.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",  # Account that owns the entity. Required.
                    "method": "str",  # Method ID. Required.
                    "arguments": [
                        {
                            "keyword": "str",  # The 'keyword' of the corresponding
                              ModelParameter. Required.
                            "value": "str"  # The value of of the argument. Always a
                              string; implementations are responsible for parsing. Required.
                        }
                    ],
                    "inputs": [
                        {
                            "entity": "str",  # The ID of the entity whose data should be
                              made available as 'keyword'. Required.
                            "keyword": "str"  # The 'keyword' specified for this input in
                              the MethodSpec. Required.
                        }
                    ],
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "scope": {
                        "dataset": "str",  # Optional. The Dataset to which the analysis
                          applies.
                        "evaluation": "str",  # Optional. The Evaluation to which the
                          analysis applies.
                        "inferenceService": "str",  # Optional. The InferenceService to which
                          the analysis applies.
                        "model": "str"  # Optional. The Model to which the analysis applies.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "method": {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "implementation": {
                            "kind": "str",  # The kind of implementation. Required.
                            "jupyterNotebook": {
                                "notebookModule": "str",  # ID of the Module that
                                  contains the notebook file. This does *not* add the Module as a
                                  dependency; you must do that separately. Required.
                                "notebookPath": "str"  # Path to the notebook file
                                  relative to the Module root directory. Required.
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python function to call. Required.
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python Rubric to run. Required.
                            }
                        },
                        "name": "str",  # Descriptive name of the Method. Required.
                        "output": {
                            "kind": "str",  # The kind of output artifact. Required.
                              Known values are: "Measurement" and "SafetyCase".
                            "measurement": {
                                "level": "str",  # Measurement level. Required. Known
                                  values are: "Dataset" and "Instance".
                                "name": "str",  # Descriptive name of the
                                  Measurement. Required.
                                "schema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            },
                            "safetyCase": {
                                "name": "str",  # Descriptive name of the SafetyCase.
                                  Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        },
                        "scope": "str",  # The scope of the Method. The Method produces
                          outputs that are specific to one entity of the type specified in the .scope
                          field. Required. Known values are: "InferenceService" and "Evaluation".
                        "description": "str",  # Optional. Long-form description, interpreted
                          as Markdown.
                        "inputs": [
                            {
                                "keyword": "str",  # The input is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "kind": "str",  # The kind of input artifact.
                                  Required. Known values are: "Dataset", "Evaluation", "Measurement",
                                  and "Report".
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ],
                        "modules": [
                            "str"  # Optional. Modules to load into the analysis
                              environment.
                        ],
                        "parameters": [
                            {
                                "keyword": "str",  # The parameter is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ]
                    },
                    "name": "str",  # Descriptive name of the SafetyCase. Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",  # The 'keyword' of the corresponding
                              ModelParameter. Required.
                            "value": "str"  # The value of of the argument. Always a
                              string; implementations are responsible for parsing. Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "entity": "str",  # The ID of the entity whose data should be
                              made available as 'keyword'. Required.
                            "keyword": "str"  # The 'keyword' specified for this input in
                              the MethodSpec. Required.
                        }
                    ],
                    "kind": "SafetyCase",  # Optional. Default value is "SafetyCase". Kind.
                      "SafetyCase"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "scope": {
                        "dataset": "str",  # Optional. The Dataset to which the analysis
                          applies.
                        "evaluation": "str",  # Optional. The Evaluation to which the
                          analysis applies.
                        "inferenceService": "str",  # Optional. The InferenceService to which
                          the analysis applies.
                        "model": "str"  # Optional. The Model to which the analysis applies.
                    },
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_safetycases_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get(self, safetycase_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get a SafetyCase by its key.

        Get a SafetyCase by its key.

        Raises a 404 error if no entity exists with that key.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",  # Account that owns the entity. Required.
                    "id": "str",  # Unique identifier of the entity. Required.
                    "method": {
                        "account": "str",  # Account that owns the entity. Required.
                        "id": "str",  # Unique identifier of the entity. Required.
                        "implementation": {
                            "kind": "str",  # The kind of implementation. Required.
                            "jupyterNotebook": {
                                "notebookModule": "str",  # ID of the Module that
                                  contains the notebook file. This does *not* add the Module as a
                                  dependency; you must do that separately. Required.
                                "notebookPath": "str"  # Path to the notebook file
                                  relative to the Module root directory. Required.
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python function to call. Required.
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"  # The fully-qualified
                                  name of the Python Rubric to run. Required.
                            }
                        },
                        "name": "str",  # Descriptive name of the Method. Required.
                        "output": {
                            "kind": "str",  # The kind of output artifact. Required.
                              Known values are: "Measurement" and "SafetyCase".
                            "measurement": {
                                "level": "str",  # Measurement level. Required. Known
                                  values are: "Dataset" and "Instance".
                                "name": "str",  # Descriptive name of the
                                  Measurement. Required.
                                "schema": {
                                    "arrowSchema": "str",  # The schema in Arrow
                                      format, encoded with dyff.schema.arrow.encode_schema(). This is
                                      required, but can be populated from a DyffDataSchema. Required.
                                    "dyffSchema": {
                                        "components": [
                                            "str"  # A list of named dyff
                                              data schemas. The final schema is the composition of
                                              these component schemas. Required.
                                        ],
                                        "schemaVersion": "0.1"  # Optional.
                                          Default value is "0.1". The dyff schema version. "0.1"
                                    },
                                    "jsonSchema": {}  # Optional. The schema in
                                      JSON Schema format.
                                },
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            },
                            "safetyCase": {
                                "name": "str",  # Descriptive name of the SafetyCase.
                                  Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        },
                        "scope": "str",  # The scope of the Method. The Method produces
                          outputs that are specific to one entity of the type specified in the .scope
                          field. Required. Known values are: "InferenceService" and "Evaluation".
                        "description": "str",  # Optional. Long-form description, interpreted
                          as Markdown.
                        "inputs": [
                            {
                                "keyword": "str",  # The input is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "kind": "str",  # The kind of input artifact.
                                  Required. Known values are: "Dataset", "Evaluation", "Measurement",
                                  and "Report".
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ],
                        "modules": [
                            "str"  # Optional. Modules to load into the analysis
                              environment.
                        ],
                        "parameters": [
                            {
                                "keyword": "str",  # The parameter is referred to by
                                  'keyword' in the context of the method implementation. Required.
                                "description": "str"  # Optional. Long-form
                                  description, interpreted as Markdown.
                            }
                        ]
                    },
                    "name": "str",  # Descriptive name of the SafetyCase. Required.
                    "annotations": [
                        {
                            "key": "str",  # The annotation key. A DNS label with an
                              optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                              Names prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.
                              See
                              https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
                              for detailed naming rules. Required.
                            "value": "str"  # The annotation value. An arbitrary string.
                              Required.
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",  # The 'keyword' of the corresponding
                              ModelParameter. Required.
                            "value": "str"  # The value of of the argument. Always a
                              string; implementations are responsible for parsing. Required.
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Resource creation time
                      (assigned by system).
                    "description": "str",  # Optional. Long-form description, interpreted as
                      Markdown.
                    "inputs": [
                        {
                            "entity": "str",  # The ID of the entity whose data should be
                              made available as 'keyword'. Required.
                            "keyword": "str"  # The 'keyword' specified for this input in
                              the MethodSpec. Required.
                        }
                    ],
                    "kind": "SafetyCase",  # Optional. Default value is "SafetyCase". Kind.
                      "SafetyCase"
                    "labels": {
                        "str": "str"  # Optional. A set of key-value labels for the resource.
                          Used to specify identifying attributes of resources that are meaningful to
                          users but do not imply semantics in the dyff system.  The keys are DNS labels
                          with an optional DNS domain prefix. For example: 'my-key', 'your.com/key_0'.
                          Keys prefixed with 'dyff.io/', 'subdomain.dyff.io/', etc. are reserved.  The
                          label values are alphanumeric characters separated by '.', '-', or '_'.  We
                          follow the kubernetes label conventions closely. See:
                          https://kubernetes.io/docs/concepts/overview/working-with-objects/labels.
                    },
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "schemaVersion": "0.1",  # Optional. Default value is "0.1". The schema
                      version. "0.1"
                    "scope": {
                        "dataset": "str",  # Optional. The Dataset to which the analysis
                          applies.
                        "evaluation": "str",  # Optional. The Evaluation to which the
                          analysis applies.
                        "inferenceService": "str",  # Optional. The InferenceService to which
                          the analysis applies.
                        "model": "str"  # Optional. The Model to which the analysis applies.
                    },
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_safetycases_get_request(
            safetycase_id=safetycase_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete(self, safetycase_id: str, **kwargs: Any) -> JSON:
        """Mark a SafetyCase for deletion.

        Mark a SafetyCase for deletion.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",  # Optional. Reason for current status (assigned by system).
                    "status": "str"  # Optional. Top-level resource status (assigned by system).
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_safetycases_delete_request(
            safetycase_id=safetycase_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def downlinks(
        self, safetycase_id: str, **kwargs: Any
    ) -> Union[List[JSON], JSON]:
        """Get a list of signed GET URLs from which safety case artifacts can be
        downloaded.

        Get a list of signed GET URLs from which safety case artifacts can be downloaded.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :return: list of JSON object or JSON object
        :rtype: list[JSON] or JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "artifact": {
                            "path": "str",  # The relative path of the artifact within
                              the tree. Required.
                            "digest": {
                                "md5": "str"  # Optional. md5 digest of artifact
                                  data.
                            },
                            "kind": "str"  # Optional. The kind of artifact.
                        },
                        "signedURL": {
                            "method": "str",  # The HTTP method applicable to the URL.
                              Required.
                            "url": "str",  # The signed URL. Required.
                            "headers": {
                                "str": "str"  # Optional. Mandatory headers that must
                                  be passed with the request.
                            }
                        }
                    }
                ]
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], JSON]] = kwargs.pop("cls", None)

        _request = build_safetycases_downlinks_request(
            safetycase_id=safetycase_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[List[JSON], JSON], deserialized), {})  # type: ignore

        return cast(Union[List[JSON], JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def logs(self, safetycase_id: str, **kwargs: Any) -> JSON:
        """Get a signed GET URL from which the logs file for the safety case run can be
        downloaded.

        Get a signed GET URL from which the logs file for the safety case run can be downloaded.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "artifact": {
                        "path": "str",  # The relative path of the artifact within the tree.
                          Required.
                        "digest": {
                            "md5": "str"  # Optional. md5 digest of artifact data.
                        },
                        "kind": "str"  # Optional. The kind of artifact.
                    },
                    "signedURL": {
                        "method": "str",  # The HTTP method applicable to the URL. Required.
                        "url": "str",  # The signed URL. Required.
                        "headers": {
                            "str": "str"  # Optional. Mandatory headers that must be
                              passed with the request.
                        }
                    }
                }
                # response body for status code(s): 422
                response == {
                    "detail": [
                        {
                            "loc": [
                                {}
                            ],
                            "msg": "str",  # Message. Required.
                            "type": "str"  # Error Type. Required.
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_safetycases_logs_request(
            safetycase_id=safetycase_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 422]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore
